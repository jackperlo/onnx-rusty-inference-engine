// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/onnx.proto`
use protobuf::{Enum, EnumOrUnknown, MessageField};
use crate::onnx_structure::attribute_proto::AttributeType;

// Generated for lite runtime
/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = protobuf::VERSION_3_7_2;

///  Attributes
///
///  A named attribute containing either singular float, integer, string, graph,
///  and tensor values, or repeated float, integer, string, graph, and tensor values.
///  An AttributeProto MUST contain the name field, and *only one* of the
///  following content fields, effectively enforcing a C/C++ union equivalent.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.AttributeProto)
pub struct AttributeProto {
  // message fields
  ///  The name field MUST be present for this version of the IR.
  // @@protoc_insertion_point(field:onnx.AttributeProto.name)
  pub name: Option<String>,
  ///  if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
  ///  In this case, this AttributeProto does not contain data, and it's a reference of attribute
  ///  in parent scope.
  ///  NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
  // @@protoc_insertion_point(field:onnx.AttributeProto.ref_attr_name)
  pub ref_attr_name: Option<String>,
  ///  A human-readable documentation for this attribute. Markdown is allowed.
  // @@protoc_insertion_point(field:onnx.AttributeProto.doc_string)
  pub doc_string: Option<String>,
  ///  The type field MUST be present for this version of the IR.
  ///  For 0.0.1 versions of the IR, this field was not defined, and
  ///  implementations needed to use has_field heuristics to determine
  ///  which value field was in use.  For IR_VERSION 0.0.2 or later, this
  ///  field MUST be set and match the f|i|s|t|... field in use.  This
  ///  change was made to accommodate proto3 implementations.
  // @@protoc_insertion_point(field:onnx.AttributeProto.type)
  pub type_: Option<protobuf::EnumOrUnknown<AttributeType>>,
  ///  Exactly ONE of the following fields must be present for this version of the IR
  // @@protoc_insertion_point(field:onnx.AttributeProto.f)
  pub f: Option<f32>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.i)
  pub i: Option<i64>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.s)
  pub s: Option<Vec<u8>>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.t)
  pub t: protobuf::MessageField<TensorProto>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.g)
  pub g: protobuf::MessageField<GraphProto>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.sparse_tensor)
  pub sparse_tensor: protobuf::MessageField<SparseTensorProto>,
  ///  Do not use field below, it's deprecated.
  ///  optional ValueProto v = 12;         // value - subsumes everything but graph
  // @@protoc_insertion_point(field:onnx.AttributeProto.tp)
  pub tp: protobuf::MessageField<TypeProto>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.floats)
  pub floats: Vec<f32>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.ints)
  pub ints: Vec<i64>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.strings)
  pub strings: Vec<Vec<u8>>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.tensors)
  pub tensors: Vec<TensorProto>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.graphs)
  pub graphs: Vec<GraphProto>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.sparse_tensors)
  pub sparse_tensors: Vec<SparseTensorProto>,
  // @@protoc_insertion_point(field:onnx.AttributeProto.type_protos)
  pub type_protos: Vec<TypeProto>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.AttributeProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a AttributeProto {
  fn default() -> &'a AttributeProto {
    <AttributeProto as protobuf::Message>::default_instance()
  }
}

impl AttributeProto {
  pub fn new() -> AttributeProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of attribute_proto
      match attribute_name {
        "name" => self.set_name(string_value),
        "ref_attr_name" => self.set_ref_attr_name(string_value),
        "doc_string" => self.set_doc_string(string_value),
        "f" => self.set_f(float_value),
        "i" => self.set_i(integer_value.into()),
        "s" => self.set_s(Vec::from(string_value)),
        "floats" => self.floats.push(float_value),
        "ints" => self.ints.push(integer_value.into()),
        "strings" => self.strings.push(Vec::from(string_value)),
        "special_fields" => {}
        _ => panic!("ATTRIBUTEPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "attributetype" => {
          match AttributeType::from_i32(integer_value) {
            Some(attribute) => self.type_ = Some(EnumOrUnknown::new(attribute)),
            None => panic!("ATTRIBUTEPROTO::ATTRIBUTETYPE cannot get correct attribute type from integer: {}", integer_value)
          }
        }
        "tensorproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            match attribute_name {
              "t" => {
                self.t = MessageField::some(TensorProto::new());
                self.t.special_fields.cached_size().set(integer_value as u32);
              },
              "tensors" => {
                self.tensors.push(TensorProto::default());
                self.tensors.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              _ => panic!("ATTTRIBUTEPROTO -> tensorproto: attribute name Add cannot be done; it does not match any TensorProto structure: {}", attribute_name)
            }
          } else {
            match current_structure[current_structure.len()-1].as_str() {
              "t" => self.t.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              "tensors" => self.tensors.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              _ => panic!("ATTTRIBUTEPROTO -> tensorproto: attribute name Dispatch cannot be done; it does not match any TensorProto structure: {}", attribute_name)
            }
          }
        }
        "graphproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            match attribute_name {
              "g" => {
                self.g = MessageField::some(GraphProto::new());
                self.g.special_fields.cached_size().set(integer_value as u32);
              },
              "graphs" => {
                self.graphs.push(GraphProto::default());
                self.graphs.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              _ => panic!("ATTTRIBUTEPROTO -> graphproto: attribute name Add cannot be done; it does not match any GraphProto structure: {}", attribute_name)
            }
          } else {
            match current_structure[current_structure.len()-1].as_str() {
              "g" => self.g.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              "graphs" => self.graphs.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              _ => panic!("ATTTRIBUTEPROTO -> graphproto: attribute name Dispatch cannot be done; it does not match any GraphProto structure: {}", attribute_name)
            }
          }
        }
        "sparsetensorproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            match attribute_name {
                "sparse_tensor" => {
                  self.sparse_tensor = MessageField::some(SparseTensorProto::new());
                  self.sparse_tensor.special_fields.cached_size().set(integer_value as u32);
                },
                "sparse_tensors" => {
                self.sparse_tensors.push(SparseTensorProto::default());
                self.sparse_tensors.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              _ => panic!("ATTTRIBUTEPROTO -> sparsetensorproto: attribute name Add cannot be done; it does not match any SparseTensorProto structure: {}", attribute_name)
            }
          } else {
            match current_structure[current_structure.len()-1].as_str() {
              "sparse_tensor" => self.sparse_tensor.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              "sparse_tensors" => self.sparse_tensors.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              _ => panic!("ATTTRIBUTEPROTO -> sparsetensorproto: attribute name Dispatch cannot be done; it does not match any SparseTensorProto structure: {}", attribute_name)
            }
          }
        }
        "typeproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            match attribute_name {
              "tp" => {
                self.tp = MessageField::some(TypeProto::new());
                self.tp.special_fields.cached_size().set(integer_value as u32);
              },
              "type_protos" => {
                self.type_protos.push(TypeProto::default());
                self.type_protos.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              _ => panic!("ATTTRIBUTEPROTO -> typeproto: attribute name Add cannot be done; it does not match any TypeProto structure: {}", attribute_name)
            }
          } else {
            match current_structure[current_structure.len()-1].as_str() {
              "tp" => self.tp.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              "type_protos" => self.type_protos.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              _ => panic!("ATTTRIBUTEPROTO -> typeproto: attribute name Dispatch cannot be done; it does not match any TypeProto structure: {}", attribute_name)
            }
          }
        }
        _ => panic!("ATTRIBUTEPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }

  // optional string name = 1;
  pub fn name(&self) -> &str {
    match self.name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_name(&mut self) {
    self.name = None;
  }

  pub fn has_name(&self) -> bool {
    self.name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_name(&mut self, v: String) {
    self.name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_name(&mut self) -> &mut String {
    if self.name.is_none() {
      self.name = Some(String::new());
    }
    self.name.as_mut().unwrap()
  }

  // Take field
  pub fn take_name(&mut self) -> String {
    self.name.take().unwrap_or_else(|| String::new())
  }

  // optional string ref_attr_name = 21;

  pub fn ref_attr_name(&self) -> &str {
    match self.ref_attr_name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_ref_attr_name(&mut self) {
    self.ref_attr_name = None;
  }

  pub fn has_ref_attr_name(&self) -> bool {
    self.ref_attr_name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_ref_attr_name(&mut self, v: String) {
    self.ref_attr_name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_ref_attr_name(&mut self) -> &mut String {
    if self.ref_attr_name.is_none() {
      self.ref_attr_name = Some(String::new());
    }
    self.ref_attr_name.as_mut().unwrap()
  }

  // Take field
  pub fn take_ref_attr_name(&mut self) -> String {
    self.ref_attr_name.take().unwrap_or_else(|| String::new())
  }

  // optional string doc_string = 13;

  pub fn doc_string(&self) -> &str {
    match self.doc_string.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_doc_string(&mut self) {
    self.doc_string = None;
  }

  pub fn has_doc_string(&self) -> bool {
    self.doc_string.is_some()
  }

  // Param is passed by value, moved
  pub fn set_doc_string(&mut self, v: String) {
    self.doc_string = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_doc_string(&mut self) -> &mut String {
    if self.doc_string.is_none() {
      self.doc_string = Some(String::new());
    }
    self.doc_string.as_mut().unwrap()
  }

  // Take field
  pub fn take_doc_string(&mut self) -> String {
    self.doc_string.take().unwrap_or_else(|| String::new())
  }

  // optional .onnx.AttributeProto.AttributeType type = 20;

  pub fn type_(&self) -> attribute_proto::AttributeType {
    match self.type_ {
      Some(e) => e.enum_value_or(attribute_proto::AttributeType::UNDEFINED),
      None => attribute_proto::AttributeType::UNDEFINED,
    }
  }

  pub fn clear_type_(&mut self) {
    self.type_ = None;
  }

  pub fn has_type(&self) -> bool {
    self.type_.is_some()
  }

  // Param is passed by value, moved
  pub fn set_type(&mut self, v: attribute_proto::AttributeType) {
    self.type_ = Some(protobuf::EnumOrUnknown::new(v));
  }

  // optional float f = 2;

  pub fn f(&self) -> f32 {
    self.f.unwrap_or(0.)
  }

  pub fn clear_f(&mut self) {
    self.f = None;
  }

  pub fn has_f(&self) -> bool {
    self.f.is_some()
  }

  // Param is passed by value, moved
  pub fn set_f(&mut self, v: f32) {
    self.f = Some(v);
  }

  // optional int64 i = 3;

  pub fn i(&self) -> i64 {
    self.i.unwrap_or(0)
  }

  pub fn clear_i(&mut self) {
    self.i = None;
  }

  pub fn has_i(&self) -> bool {
    self.i.is_some()
  }

  // Param is passed by value, moved
  pub fn set_i(&mut self, v: i64) {
    self.i = Some(v);
  }

  // optional bytes s = 4;

  pub fn s(&self) -> &[u8] {
    match self.s.as_ref() {
      Some(v) => v,
      None => &[],
    }
  }

  pub fn clear_s(&mut self) {
    self.s = None;
  }

  pub fn has_s(&self) -> bool {
    self.s.is_some()
  }

  // Param is passed by value, moved
  pub fn set_s(&mut self, v: Vec<u8>) {
    self.s = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_s(&mut self) -> &mut Vec<u8> {
    if self.s.is_none() {
      self.s = Some(Vec::new());
    }
    self.s.as_mut().unwrap()
  }

  // Take field
  pub fn take_s(&mut self) -> Vec<u8> {
    self.s.take().unwrap_or_else(|| Vec::new())
  }
}

impl protobuf::Message for AttributeProto {
  const NAME: &'static str = "AttributeProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.name = Some(is.read_string()?);
        }
        170 => {
          self.ref_attr_name = Some(is.read_string()?);
        }
        106 => {
          self.doc_string = Some(is.read_string()?);
        }
        160 => {
          self.type_ = Some(is.read_enum_or_unknown()?);
        }
        21 => {
          self.f = Some(is.read_float()?);
        }
        24 => {
          self.i = Some(is.read_int64()?);
        }
        34 => {
          self.s = Some(is.read_bytes()?);
        }
        42 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.t)?;
        }
        50 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.g)?;
        }
        178 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.sparse_tensor)?;
        }
        114 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.tp)?;
        }
        58 => {
          is.read_repeated_packed_float_into(&mut self.floats)?;
        }
        61 => {
          self.floats.push(is.read_float()?);
        }
        66 => {
          is.read_repeated_packed_int64_into(&mut self.ints)?;
        }
        64 => {
          self.ints.push(is.read_int64()?);
        }
        74 => {
          self.strings.push(is.read_bytes()?);
        }
        82 => {
          self.tensors.push(is.read_message()?);
        }
        90 => {
          self.graphs.push(is.read_message()?);
        }
        186 => {
          self.sparse_tensors.push(is.read_message()?);
        }
        122 => {
          self.type_protos.push(is.read_message()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.name.as_ref() {
      os.write_string(1, v)?;
    }
    if let Some(v) = self.ref_attr_name.as_ref() {
      os.write_string(21, v)?;
    }
    if let Some(v) = self.doc_string.as_ref() {
      os.write_string(13, v)?;
    }
    if let Some(v) = self.type_ {
      os.write_enum(20, protobuf::EnumOrUnknown::value(&v))?;
    }
    if let Some(v) = self.f {
      os.write_float(2, v)?;
    }
    if let Some(v) = self.i {
      os.write_int64(3, v)?;
    }
    if let Some(v) = self.s.as_ref() {
      os.write_bytes(4, v)?;
    }
    if let Some(v) = self.t.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
    }
    if let Some(v) = self.g.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
    }
    if let Some(v) = self.sparse_tensor.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
    }
    if let Some(v) = self.tp.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
    }
    for v in &self.floats {
      os.write_float(7, *v)?;
    };
    for v in &self.ints {
      os.write_int64(8, *v)?;
    };
    for v in &self.strings {
      os.write_bytes(9, &v)?;
    };
    for v in &self.tensors {
      protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
    };
    for v in &self.graphs {
      protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
    };
    for v in &self.sparse_tensors {
      protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
    };
    for v in &self.type_protos {
      protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
    };
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.name.as_ref() {
      my_size += protobuf::rt::string_size(1, &v);
    }
    if let Some(v) = self.ref_attr_name.as_ref() {
      my_size += protobuf::rt::string_size(21, &v);
    }
    if let Some(v) = self.doc_string.as_ref() {
      my_size += protobuf::rt::string_size(13, &v);
    }
    if let Some(v) = self.type_ {
      my_size += protobuf::rt::int32_size(20, v.value());
    }
    if let Some(v) = self.f {
      my_size += 1 + 4;
    }
    if let Some(v) = self.i {
      my_size += protobuf::rt::int64_size(3, v);
    }
    if let Some(v) = self.s.as_ref() {
      my_size += protobuf::rt::bytes_size(4, &v);
    }
    if let Some(v) = self.t.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    if let Some(v) = self.g.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    if let Some(v) = self.sparse_tensor.as_ref() {
      let len = v.compute_size();
      my_size += 2 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    if let Some(v) = self.tp.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    my_size += 5 * self.floats.len() as u64;
    for value in &self.ints {
      my_size += protobuf::rt::int64_size(8, *value);
    };
    for value in &self.strings {
      my_size += protobuf::rt::bytes_size(9, &value);
    };
    for value in &self.tensors {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.graphs {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.sparse_tensors {
      let len = value.compute_size();
      my_size += 2 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.type_protos {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> AttributeProto {
    AttributeProto::new()
  }

  fn clear(&mut self) {
    self.name = None;
    self.ref_attr_name = None;
    self.doc_string = None;
    self.type_ = None;
    self.f = None;
    self.i = None;
    self.s = None;
    self.t.clear();
    self.g.clear();
    self.sparse_tensor.clear();
    self.tp.clear();
    self.floats.clear();
    self.ints.clear();
    self.strings.clear();
    self.tensors.clear();
    self.graphs.clear();
    self.sparse_tensors.clear();
    self.type_protos.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static AttributeProto {
    static instance: AttributeProto = AttributeProto {
      name: None,
      ref_attr_name: None,
      doc_string: None,
      type_: None,
      f: None,
      i: None,
      s: None,
      t: protobuf::MessageField::none(),
      g: protobuf::MessageField::none(),
      sparse_tensor: protobuf::MessageField::none(),
      tp: protobuf::MessageField::none(),
      floats: Vec::new(),
      ints: Vec::new(),
      strings: Vec::new(),
      tensors: Vec::new(),
      graphs: Vec::new(),
      sparse_tensors: Vec::new(),
      type_protos: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

/// Nested message and enums of message `AttributeProto`
pub mod attribute_proto {
  ///  Note: this enum is structurally identical to the OpSchema::AttrType
  ///  enum defined in schema.h.  If you rev one, you likely need to rev the other.
  #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
  // @@protoc_insertion_point(enum:onnx.AttributeProto.AttributeType)
  pub enum AttributeType {
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.UNDEFINED)
    UNDEFINED = 0,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.FLOAT)
    FLOAT = 1,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.INT)
    INT = 2,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.STRING)
    STRING = 3,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TENSOR)
    TENSOR = 4,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.GRAPH)
    GRAPH = 5,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.SPARSE_TENSOR)
    SPARSE_TENSOR = 11,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TYPE_PROTO)
    TYPE_PROTO = 13,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.FLOATS)
    FLOATS = 6,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.INTS)
    INTS = 7,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.STRINGS)
    STRINGS = 8,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TENSORS)
    TENSORS = 9,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.GRAPHS)
    GRAPHS = 10,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.SPARSE_TENSORS)
    SPARSE_TENSORS = 12,
    // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TYPE_PROTOS)
    TYPE_PROTOS = 14,
  }

  impl protobuf::Enum for AttributeType {
    const NAME: &'static str = "AttributeType";

    fn value(&self) -> i32 {
      *self as i32
    }

    fn from_i32(value: i32) -> Option<AttributeType> {
      match value {
        0 => Some(AttributeType::UNDEFINED),
        1 => Some(AttributeType::FLOAT),
        2 => Some(AttributeType::INT),
        3 => Some(AttributeType::STRING),
        4 => Some(AttributeType::TENSOR),
        5 => Some(AttributeType::GRAPH),
        11 => Some(AttributeType::SPARSE_TENSOR),
        13 => Some(AttributeType::TYPE_PROTO),
        6 => Some(AttributeType::FLOATS),
        7 => Some(AttributeType::INTS),
        8 => Some(AttributeType::STRINGS),
        9 => Some(AttributeType::TENSORS),
        10 => Some(AttributeType::GRAPHS),
        12 => Some(AttributeType::SPARSE_TENSORS),
        14 => Some(AttributeType::TYPE_PROTOS),
        _ => None
      }
    }

    fn from_str(s: &str) -> Option<Self> {
      todo!()
    }

    const VALUES: &'static [AttributeType] = &[
      AttributeType::UNDEFINED,
      AttributeType::FLOAT,
      AttributeType::INT,
      AttributeType::STRING,
      AttributeType::TENSOR,
      AttributeType::GRAPH,
      AttributeType::SPARSE_TENSOR,
      AttributeType::TYPE_PROTO,
      AttributeType::FLOATS,
      AttributeType::INTS,
      AttributeType::STRINGS,
      AttributeType::TENSORS,
      AttributeType::GRAPHS,
      AttributeType::SPARSE_TENSORS,
      AttributeType::TYPE_PROTOS,
    ];
  }

  impl Default for AttributeType {
    fn default() -> Self {
      AttributeType::UNDEFINED
    }
  }
}

///  Defines information on value, including the name, the type, and
///  the shape of the value.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.ValueInfoProto)
pub struct ValueInfoProto {
  // message fields
  ///  This field MUST be present in this version of the IR.
  // @@protoc_insertion_point(field:onnx.ValueInfoProto.name)
  pub name: Option<String>,
  ///  This field MUST be present in this version of the IR for
  ///  inputs and outputs of the top-level graph.
  // @@protoc_insertion_point(field:onnx.ValueInfoProto.type)
  pub type_: protobuf::MessageField<TypeProto>,
  ///  A human-readable documentation for this value. Markdown is allowed.
  // @@protoc_insertion_point(field:onnx.ValueInfoProto.doc_string)
  pub doc_string: Option<String>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.ValueInfoProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a ValueInfoProto {
  fn default() -> &'a ValueInfoProto {
    <ValueInfoProto as protobuf::Message>::default_instance()
  }
}

impl ValueInfoProto {
  pub fn new() -> ValueInfoProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of value_info_proto
      match attribute_name {
        "name" => self.set_name(string_value),
        "doc_string" => self.set_doc_string(string_value),
        "special_fields" => {}
        _ => panic!("VALUEINFOPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "typeproto" => {
          match self.type_.as_mut() {
            None => {
              self.type_ = MessageField::some(TypeProto::new());
              match self.type_.as_mut() {
                None => { panic!("VALUEINFOPROTO dispatcher, cannot insert len"); }
                Some(t) => { t.special_fields.cached_size().set(integer_value as u32); }
              }
            }
            Some(t) => t.dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add)
          }
        }
        _ => panic!("VALUEINFOPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }

  // optional string name = 1;
  pub fn name(&self) -> &str {
    match self.name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_name(&mut self) {
    self.name = None;
  }

  pub fn has_name(&self) -> bool {
    self.name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_name(&mut self, v: String) {
    self.name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_name(&mut self) -> &mut String {
    if self.name.is_none() {
      self.name = Some(String::new());
    }
    self.name.as_mut().unwrap()
  }

  // Take field
  pub fn take_name(&mut self) -> String {
    self.name.take().unwrap_or_else(|| String::new())
  }

  // optional string doc_string = 3;

  pub fn doc_string(&self) -> &str {
    match self.doc_string.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_doc_string(&mut self) {
    self.doc_string = None;
  }

  pub fn has_doc_string(&self) -> bool {
    self.doc_string.is_some()
  }

  // Param is passed by value, moved
  pub fn set_doc_string(&mut self, v: String) {
    self.doc_string = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_doc_string(&mut self) -> &mut String {
    if self.doc_string.is_none() {
      self.doc_string = Some(String::new());
    }
    self.doc_string.as_mut().unwrap()
  }

  // Take field
  pub fn take_doc_string(&mut self) -> String {
    self.doc_string.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for ValueInfoProto {
  const NAME: &'static str = "ValueInfoProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.name = Some(is.read_string()?);
        }
        18 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
        }
        26 => {
          self.doc_string = Some(is.read_string()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.name.as_ref() {
      os.write_string(1, v)?;
    }
    if let Some(v) = self.type_.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
    }
    if let Some(v) = self.doc_string.as_ref() {
      os.write_string(3, v)?;
    }
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.name.as_ref() {
      my_size += protobuf::rt::string_size(1, &v);
    }
    if let Some(v) = self.type_.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    if let Some(v) = self.doc_string.as_ref() {
      my_size += protobuf::rt::string_size(3, &v);
    }
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> ValueInfoProto {
    ValueInfoProto::new()
  }

  fn clear(&mut self) {
    self.name = None;
    self.type_.clear();
    self.doc_string = None;
    self.special_fields.clear();
  }

  fn default_instance() -> &'static ValueInfoProto {
    static instance: ValueInfoProto = ValueInfoProto {
      name: None,
      type_: protobuf::MessageField::none(),
      doc_string: None,
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  Nodes
///
///  Computation graphs are made up of a DAG of nodes, which represent what is
///  commonly called a "layer" or "pipeline stage" in machine learning frameworks.
///
///  For example, it can be a node of type "Conv" that takes in an image, a filter
///  tensor and a bias tensor, and produces the convolved output.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.NodeProto)
pub struct NodeProto {
  // message fields
  // @@protoc_insertion_point(field:onnx.NodeProto.input)
  pub input: Vec<String>,
  // @@protoc_insertion_point(field:onnx.NodeProto.output)
  pub output: Vec<String>,
  ///  An optional identifier for this node in a graph.
  ///  This field MAY be absent in ths version of the IR.
  // @@protoc_insertion_point(field:onnx.NodeProto.name)
  pub name: Option<String>,
  ///  The symbolic identifier of the Operator to execute.
  // @@protoc_insertion_point(field:onnx.NodeProto.op_type)
  pub op_type: Option<String>,
  ///  The domain of the OperatorSet that specifies the operator named by op_type.
  // @@protoc_insertion_point(field:onnx.NodeProto.domain)
  pub domain: Option<String>,
  ///  Additional named attributes.
  // @@protoc_insertion_point(field:onnx.NodeProto.attribute)
  pub attribute: Vec<AttributeProto>,
  ///  A human-readable documentation for this node. Markdown is allowed.
  // @@protoc_insertion_point(field:onnx.NodeProto.doc_string)
  pub doc_string: Option<String>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.NodeProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a NodeProto {
  fn default() -> &'a NodeProto {
    <NodeProto as protobuf::Message>::default_instance()
  }
}

impl NodeProto {
  pub fn new() -> NodeProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of node_proto
      match attribute_name {
        "input" => self.input.push(string_value),
        "output" => self.output.push(string_value),
        "name" => self.set_name(string_value),
        "op_type" => self.set_op_type(string_value),
        "domain" => self.set_domain(string_value),
        "doc_string" => self.set_doc_string(string_value),
        "special_fields" => {}
        _ => panic!("NODEPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "attributeproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.attribute.push(AttributeProto::default());
            self.attribute.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.attribute.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        _ => panic!("NODEPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }

  // optional string name = 3;
  pub fn name(&self) -> &str {
    match self.name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_name(&mut self) {
    self.name = None;
  }

  pub fn has_name(&self) -> bool {
    self.name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_name(&mut self, v: String) {
    self.name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_name(&mut self) -> &mut String {
    if self.name.is_none() {
      self.name = Some(String::new());
    }
    self.name.as_mut().unwrap()
  }

  // Take field
  pub fn take_name(&mut self) -> String {
    self.name.take().unwrap_or_else(|| String::new())
  }

  // optional string op_type = 4;

  pub fn op_type(&self) -> &str {
    match self.op_type.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_op_type(&mut self) {
    self.op_type = None;
  }

  pub fn has_op_type(&self) -> bool {
    self.op_type.is_some()
  }

  // Param is passed by value, moved
  pub fn set_op_type(&mut self, v: String) {
    self.op_type = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_op_type(&mut self) -> &mut String {
    if self.op_type.is_none() {
      self.op_type = Some(String::new());
    }
    self.op_type.as_mut().unwrap()
  }

  // Take field
  pub fn take_op_type(&mut self) -> String {
    self.op_type.take().unwrap_or_else(|| String::new())
  }

  // optional string domain = 7;

  pub fn domain(&self) -> &str {
    match self.domain.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_domain(&mut self) {
    self.domain = None;
  }

  pub fn has_domain(&self) -> bool {
    self.domain.is_some()
  }

  // Param is passed by value, moved
  pub fn set_domain(&mut self, v: String) {
    self.domain = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_domain(&mut self) -> &mut String {
    if self.domain.is_none() {
      self.domain = Some(String::new());
    }
    self.domain.as_mut().unwrap()
  }

  // Take field
  pub fn take_domain(&mut self) -> String {
    self.domain.take().unwrap_or_else(|| String::new())
  }

  // optional string doc_string = 6;

  pub fn doc_string(&self) -> &str {
    match self.doc_string.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_doc_string(&mut self) {
    self.doc_string = None;
  }

  pub fn has_doc_string(&self) -> bool {
    self.doc_string.is_some()
  }

  // Param is passed by value, moved
  pub fn set_doc_string(&mut self, v: String) {
    self.doc_string = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_doc_string(&mut self) -> &mut String {
    if self.doc_string.is_none() {
      self.doc_string = Some(String::new());
    }
    self.doc_string.as_mut().unwrap()
  }

  // Take field
  pub fn take_doc_string(&mut self) -> String {
    self.doc_string.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for NodeProto {
  const NAME: &'static str = "NodeProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.input.push(is.read_string()?);
        }
        18 => {
          self.output.push(is.read_string()?);
        }
        26 => {
          self.name = Some(is.read_string()?);
        }
        34 => {
          self.op_type = Some(is.read_string()?);
        }
        58 => {
          self.domain = Some(is.read_string()?);
        }
        42 => {
          self.attribute.push(is.read_message()?);
        }
        50 => {
          self.doc_string = Some(is.read_string()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    for v in &self.input {
      os.write_string(1, &v)?;
    };
    for v in &self.output {
      os.write_string(2, &v)?;
    };
    if let Some(v) = self.name.as_ref() {
      os.write_string(3, v)?;
    }
    if let Some(v) = self.op_type.as_ref() {
      os.write_string(4, v)?;
    }
    if let Some(v) = self.domain.as_ref() {
      os.write_string(7, v)?;
    }
    for v in &self.attribute {
      protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
    };
    if let Some(v) = self.doc_string.as_ref() {
      os.write_string(6, v)?;
    }
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    for value in &self.input {
      my_size += protobuf::rt::string_size(1, &value);
    };
    for value in &self.output {
      my_size += protobuf::rt::string_size(2, &value);
    };
    if let Some(v) = self.name.as_ref() {
      my_size += protobuf::rt::string_size(3, &v);
    }
    if let Some(v) = self.op_type.as_ref() {
      my_size += protobuf::rt::string_size(4, &v);
    }
    if let Some(v) = self.domain.as_ref() {
      my_size += protobuf::rt::string_size(7, &v);
    }
    for value in &self.attribute {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    if let Some(v) = self.doc_string.as_ref() {
      my_size += protobuf::rt::string_size(6, &v);
    }
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> NodeProto {
    NodeProto::new()
  }

  fn clear(&mut self) {
    self.input.clear();
    self.output.clear();
    self.name = None;
    self.op_type = None;
    self.domain = None;
    self.attribute.clear();
    self.doc_string = None;
    self.special_fields.clear();
  }

  fn default_instance() -> &'static NodeProto {
    static instance: NodeProto = NodeProto {
      input: Vec::new(),
      output: Vec::new(),
      name: None,
      op_type: None,
      domain: None,
      attribute: Vec::new(),
      doc_string: None,
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  Training information
///  TrainingInfoProto stores information for training a model.
///  In particular, this defines two functionalities: an initialization-step
///  and a training-algorithm-step. Initialization resets the model
///  back to its original state as if no training has been performed.
///  Training algorithm improves the model based on input data.
///
///  The semantics of the initialization-step is that the initializers
///  in ModelProto.graph and in TrainingInfoProto.algorithm are first
///  initialized as specified by the initializers in the graph, and then
///  updated by the "initialization_binding" in every instance in
///  ModelProto.training_info.
///
///  The field "algorithm" defines a computation graph which represents a
///  training algorithm's step. After the execution of a
///  TrainingInfoProto.algorithm, the initializers specified by "update_binding"
///  may be immediately updated. If the targeted training algorithm contains
///  consecutive update steps (such as block coordinate descent methods),
///  the user needs to create a TrainingInfoProto for each step.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.TrainingInfoProto)
pub struct TrainingInfoProto {
  // message fields
  ///  This field describes a graph to compute the initial tensors
  ///  upon starting the training process. Initialization graph has no input
  ///  and can have multiple outputs. Usually, trainable tensors in neural
  ///  networks are randomly initialized. To achieve that, for each tensor,
  ///  the user can put a random number operator such as RandomNormal or
  ///  RandomUniform in TrainingInfoProto.initialization.node and assign its
  ///  random output to the specific tensor using "initialization_binding".
  ///  This graph can also set the initializers in "algorithm" in the same
  ///  TrainingInfoProto; a use case is resetting the number of training
  ///  iteration to zero.
  ///
  ///  By default, this field is an empty graph and its evaluation does not
  ///  produce any output. Thus, no initializer would be changed by default.
  // @@protoc_insertion_point(field:onnx.TrainingInfoProto.initialization)
  pub initialization: protobuf::MessageField<GraphProto>,
  // @@protoc_insertion_point(field:onnx.TrainingInfoProto.algorithm)
  pub algorithm: protobuf::MessageField<GraphProto>,
  ///  This field specifies the bindings from the outputs of "initialization" to
  ///  some initializers in "ModelProto.graph.initializer" and
  ///  the "algorithm.initializer" in the same TrainingInfoProto.
  ///  See "update_binding" below for details.
  ///
  ///  By default, this field is empty and no initializer would be changed
  ///  by the execution of "initialization".
  // @@protoc_insertion_point(field:onnx.TrainingInfoProto.initialization_binding)
  pub initialization_binding: Vec<StringStringEntryProto>,
  // @@protoc_insertion_point(field:onnx.TrainingInfoProto.update_binding)
  pub update_binding: Vec<StringStringEntryProto>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.TrainingInfoProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a TrainingInfoProto {
  fn default() -> &'a TrainingInfoProto {
    <TrainingInfoProto as protobuf::Message>::default_instance()
  }
}

impl TrainingInfoProto {
  pub fn new() -> TrainingInfoProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of training_info_proto
      match attribute_name {
        "special_fields" => {}
        _ => panic!("TRAININGINFOPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "graphproto" => {
          match attribute_name {
            "initialization" => self.initialization.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
            "algorithm" => self.algorithm.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
            _ => panic!("TRAININGINFOPROTO -> graphproto: attribute name not found!: {}", attribute_name)
          }
        }
        "stringstringentryproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            match attribute_name {
              "initialization_binding" => {
                self.initialization_binding.push(StringStringEntryProto::default());
                self.initialization_binding.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              "update_binding" => {
                self.update_binding.push(StringStringEntryProto::default());
                self.update_binding.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              _ => panic!("TRAININGINFOPROTO -> stringstringentryproto: cannot add element to: {}; not found.", attribute_name)
            }
          } else {
            match attribute_name {
              "initialization_binding" => self.initialization_binding.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              "update_binding" => self.update_binding.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              _ => panic!("TRAININGINFOPROTO -> stringstringentryproto: cannot dispatch element: {}; not found.", attribute_name)
            }
          }
        }
        _ => panic!("TRAININGINFOPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }
}

impl protobuf::Message for TrainingInfoProto {
  const NAME: &'static str = "TrainingInfoProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.initialization)?;
        }
        18 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.algorithm)?;
        }
        26 => {
          self.initialization_binding.push(is.read_message()?);
        }
        34 => {
          self.update_binding.push(is.read_message()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.initialization.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
    }
    if let Some(v) = self.algorithm.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
    }
    for v in &self.initialization_binding {
      protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
    };
    for v in &self.update_binding {
      protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
    };
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.initialization.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    if let Some(v) = self.algorithm.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    for value in &self.initialization_binding {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.update_binding {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> TrainingInfoProto {
    TrainingInfoProto::new()
  }

  fn clear(&mut self) {
    self.initialization.clear();
    self.algorithm.clear();
    self.initialization_binding.clear();
    self.update_binding.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static TrainingInfoProto {
    static instance: TrainingInfoProto = TrainingInfoProto {
      initialization: protobuf::MessageField::none(),
      algorithm: protobuf::MessageField::none(),
      initialization_binding: Vec::new(),
      update_binding: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  Models
///
///  ModelProto is a top-level file/container format for bundling a ML model and
///  associating its computation graph with metadata.
///
///  The semantics of the model are described by the associated GraphProto's.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.ModelProto)
pub struct ModelProto {
  // message fields
  ///  The version of the IR this model targets. See Version enum above.
  ///  This field MUST be present.
  // @@protoc_insertion_point(field:onnx.ModelProto.ir_version)
  pub ir_version: Option<i64>,
  ///  The OperatorSets this model relies on.
  ///  All ModelProtos MUST have at least one entry that
  ///  specifies which version of the ONNX OperatorSet is
  ///  being imported.
  ///
  ///  All nodes in the ModelProto's graph will bind against the operator
  ///  with the same-domain/same-op_type operator with the HIGHEST version
  ///  in the referenced operator sets.
  // @@protoc_insertion_point(field:onnx.ModelProto.opset_import)
  pub opset_import: Vec<OperatorSetIdProto>,
  ///  The name of the framework or tool used to generate this model.
  ///  This field SHOULD be present to indicate which implementation/tool/framework
  ///  emitted the model.
  // @@protoc_insertion_point(field:onnx.ModelProto.producer_name)
  pub producer_name: Option<String>,
  ///  The version of the framework or tool used to generate this model.
  ///  This field SHOULD be present to indicate which implementation/tool/framework
  ///  emitted the model.
  // @@protoc_insertion_point(field:onnx.ModelProto.producer_version)
  pub producer_version: Option<String>,
  ///  Domain name of the model.
  ///  We use reverse domain names as name space indicators. For example:
  ///  `com.facebook.fair` or `com.microsoft.cognitiveservices`
  ///
  ///  Together with `model_version` and GraphProto.name, this forms the unique identity of
  ///  the graph.
  // @@protoc_insertion_point(field:onnx.ModelProto.domain)
  pub domain: Option<String>,
  ///  The version of the graph encoded. See Version enum below.
  // @@protoc_insertion_point(field:onnx.ModelProto.model_version)
  pub model_version: Option<i64>,
  ///  A human-readable documentation for this model. Markdown is allowed.
  // @@protoc_insertion_point(field:onnx.ModelProto.doc_string)
  pub doc_string: Option<String>,
  ///  The parameterized graph that is evaluated to execute the model.
  // @@protoc_insertion_point(field:onnx.ModelProto.graph)
  pub graph: protobuf::MessageField<GraphProto>,
  ///  Named metadata values; keys should be distinct.
  // @@protoc_insertion_point(field:onnx.ModelProto.metadata_props)
  pub metadata_props: Vec<StringStringEntryProto>,
  ///  Training-specific information. Sequentially executing all stored
  ///  `TrainingInfoProto.algorithm`s and assigning their outputs following
  ///  the corresponding `TrainingInfoProto.update_binding`s is one training
  ///  iteration. Similarly, to initialize the model
  ///  (as if training hasn't happened), the user should sequentially execute
  ///  all stored `TrainingInfoProto.initialization`s and assigns their outputs
  ///  using `TrainingInfoProto.initialization_binding`s.
  ///
  ///  If this field is empty, the training behavior of the model is undefined.
  // @@protoc_insertion_point(field:onnx.ModelProto.training_info)
  pub training_info: Vec<TrainingInfoProto>,
  ///  A list of function protos local to the model.
  ///
  ///  Name of the function "FunctionProto.name" should be unique within the domain "FunctionProto.domain".
  ///  In case of any conflicts the behavior (whether the model local functions are given higher priority,
  ///  or standard operator sets are given higher priotity or this is treated as error) is defined by
  ///  the runtimes.
  ///
  ///  The operator sets imported by FunctionProto should be compatible with the ones
  ///  imported by ModelProto and other model local FunctionProtos.
  ///  Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
  ///  or by 2 FunctionProtos then versions for the operator set may be different but,
  ///  the operator schema returned for op_type, domain, version combination
  ///  for both the versions should be same for every node in the function body.
  ///
  ///  One FunctionProto can reference other FunctionProto in the model, however, recursive reference
  ///  is not allowed.
  // @@protoc_insertion_point(field:onnx.ModelProto.functions)
  pub functions: Vec<FunctionProto>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.ModelProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a ModelProto {
  fn default() -> &'a ModelProto {
    <ModelProto as protobuf::Message>::default_instance()
  }
}

impl ModelProto
{
  pub fn new() -> ModelProto {
    Default::default()
  }
  /*
  new_structure_to_add: true only when a new structure is found from the reading of the .onnx and so needs to be added
  */
  pub(crate) fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of model_proto
      match attribute_name {
        "ir_version" => self.set_ir_version(integer_value.into()),
        "producer_name" => self.set_producer_name(string_value),
        "producer_version" => self.set_producer_version(string_value),
        "domain" => self.set_domain(string_value),
        "model_version" => self.set_model_version(integer_value.into()),
        "doc_string" => self.set_doc_string(string_value),
        "special_fields" => {}
        _ => panic!("MODELPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "operatorsetidproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.opset_import.push(OperatorSetIdProto::default());
            self.opset_import.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.opset_import.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "graphproto" => {
          match self.graph.as_mut() {
            None => {
              self.graph = MessageField::some(GraphProto::new());
              match self.graph.as_mut() {
                None => { panic!("GRAPHPROTO dispatcher, cannot insert len"); }
                Some(g) => { g.special_fields.cached_size().set(integer_value as u32); }
              }
            }
            Some(g) => g.dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add)
          }
        }
        "stringstringentryproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.metadata_props.push(StringStringEntryProto::default());
            self.metadata_props.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.metadata_props.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "traininginfoproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.training_info.push(TrainingInfoProto::default());
            self.training_info.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.training_info.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "functionproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.functions.push(FunctionProto::default());
            self.functions.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.functions.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        _ => panic!("MODELPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }

  // optional int64 ir_version = 1;
  pub fn ir_version(&self) -> i64 {
    self.ir_version.unwrap_or(0)
  }

  pub fn clear_ir_version(&mut self) {
    self.ir_version = None;
  }

  pub fn has_ir_version(&self) -> bool {
    self.ir_version.is_some()
  }

  // Param is passed by value, moved
  pub fn set_ir_version(&mut self, v: i64) {
    self.ir_version = Some(v);
  }

  // optional string producer_name = 2;

  pub fn producer_name(&self) -> &str {
    match self.producer_name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_producer_name(&mut self) {
    self.producer_name = None;
  }

  pub fn has_producer_name(&self) -> bool {
    self.producer_name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_producer_name(&mut self, v: String) {
    self.producer_name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_producer_name(&mut self) -> &mut String {
    if self.producer_name.is_none() {
      self.producer_name = Some(String::new());
    }
    self.producer_name.as_mut().unwrap()
  }

  // Take field
  pub fn take_producer_name(&mut self) -> String {
    self.producer_name.take().unwrap_or_else(|| String::new())
  }

  // optional string producer_version = 3;

  pub fn producer_version(&self) -> &str {
    match self.producer_version.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_producer_version(&mut self) {
    self.producer_version = None;
  }

  pub fn has_producer_version(&self) -> bool {
    self.producer_version.is_some()
  }

  // Param is passed by value, moved
  pub fn set_producer_version(&mut self, v: String) {
    self.producer_version = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_producer_version(&mut self) -> &mut String {
    if self.producer_version.is_none() {
      self.producer_version = Some(String::new());
    }
    self.producer_version.as_mut().unwrap()
  }

  // Take field
  pub fn take_producer_version(&mut self) -> String {
    self.producer_version.take().unwrap_or_else(|| String::new())
  }

  // optional string domain = 4;

  pub fn domain(&self) -> &str {
    match self.domain.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_domain(&mut self) {
    self.domain = None;
  }

  pub fn has_domain(&self) -> bool {
    self.domain.is_some()
  }

  // Param is passed by value, moved
  pub fn set_domain(&mut self, v: String) {
    self.domain = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_domain(&mut self) -> &mut String {
    if self.domain.is_none() {
      self.domain = Some(String::new());
    }
    self.domain.as_mut().unwrap()
  }

  // Take field
  pub fn take_domain(&mut self) -> String {
    self.domain.take().unwrap_or_else(|| String::new())
  }

  // optional int64 model_version = 5;

  pub fn model_version(&self) -> i64 {
    self.model_version.unwrap_or(0)
  }

  pub fn clear_model_version(&mut self) {
    self.model_version = None;
  }

  pub fn has_model_version(&self) -> bool {
    self.model_version.is_some()
  }

  // Param is passed by value, moved
  pub fn set_model_version(&mut self, v: i64) {
    self.model_version = Some(v);
  }

  // optional string doc_string = 6;

  pub fn doc_string(&self) -> &str {
    match self.doc_string.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_doc_string(&mut self) {
    self.doc_string = None;
  }

  pub fn has_doc_string(&self) -> bool {
    self.doc_string.is_some()
  }

  // Param is passed by value, moved
  pub fn set_doc_string(&mut self, v: String) {
    self.doc_string = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_doc_string(&mut self) -> &mut String {
    if self.doc_string.is_none() {
      self.doc_string = Some(String::new());
    }
    self.doc_string.as_mut().unwrap()
  }

  // Take field
  pub fn take_doc_string(&mut self) -> String {
    self.doc_string.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for ModelProto {
  const NAME: &'static str = "ModelProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        8 => {
          self.ir_version = Some(is.read_int64()?);
        }
        66 => {
          self.opset_import.push(is.read_message()?);
        }
        18 => {
          self.producer_name = Some(is.read_string()?);
        }
        26 => {
          self.producer_version = Some(is.read_string()?);
        }
        34 => {
          self.domain = Some(is.read_string()?);
        }
        40 => {
          self.model_version = Some(is.read_int64()?);
        }
        50 => {
          self.doc_string = Some(is.read_string()?);
        }
        58 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.graph)?;
        }
        114 => {
          self.metadata_props.push(is.read_message()?);
        }
        162 => {
          self.training_info.push(is.read_message()?);
        }
        202 => {
          self.functions.push(is.read_message()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.ir_version {
      os.write_int64(1, v)?;
    }
    for v in &self.opset_import {
      protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
    };
    if let Some(v) = self.producer_name.as_ref() {
      os.write_string(2, v)?;
    }
    if let Some(v) = self.producer_version.as_ref() {
      os.write_string(3, v)?;
    }
    if let Some(v) = self.domain.as_ref() {
      os.write_string(4, v)?;
    }
    if let Some(v) = self.model_version {
      os.write_int64(5, v)?;
    }
    if let Some(v) = self.doc_string.as_ref() {
      os.write_string(6, v)?;
    }
    if let Some(v) = self.graph.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
    }
    for v in &self.metadata_props {
      protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
    };
    for v in &self.training_info {
      protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
    };
    for v in &self.functions {
      protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
    };
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.ir_version {
      my_size += protobuf::rt::int64_size(1, v);
    }
    for value in &self.opset_import {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    if let Some(v) = self.producer_name.as_ref() {
      my_size += protobuf::rt::string_size(2, &v);
    }
    if let Some(v) = self.producer_version.as_ref() {
      my_size += protobuf::rt::string_size(3, &v);
    }
    if let Some(v) = self.domain.as_ref() {
      my_size += protobuf::rt::string_size(4, &v);
    }
    if let Some(v) = self.model_version {
      my_size += protobuf::rt::int64_size(5, v);
    }
    if let Some(v) = self.doc_string.as_ref() {
      my_size += protobuf::rt::string_size(6, &v);
    }
    if let Some(v) = self.graph.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    for value in &self.metadata_props {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.training_info {
      let len = value.compute_size();
      my_size += 2 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.functions {
      let len = value.compute_size();
      my_size += 2 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> ModelProto {
    ModelProto::new()
  }

  fn clear(&mut self) {
    self.ir_version = None;
    self.opset_import.clear();
    self.producer_name = None;
    self.producer_version = None;
    self.domain = None;
    self.model_version = None;
    self.doc_string = None;
    self.graph.clear();
    self.metadata_props.clear();
    self.training_info.clear();
    self.functions.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static ModelProto {
    static instance: ModelProto = ModelProto {
      ir_version: None,
      opset_import: Vec::new(),
      producer_name: None,
      producer_version: None,
      domain: None,
      model_version: None,
      doc_string: None,
      graph: protobuf::MessageField::none(),
      metadata_props: Vec::new(),
      training_info: Vec::new(),
      functions: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  StringStringEntryProto follows the pattern for cross-proto-version maps.
///  See https://developers.google.com/protocol-buffers/docs/proto3#maps
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.StringStringEntryProto)
pub struct StringStringEntryProto {
  // message fields
  // @@protoc_insertion_point(field:onnx.StringStringEntryProto.key)
  pub key: Option<String>,
  // @@protoc_insertion_point(field:onnx.StringStringEntryProto.value)
  pub value: Option<String>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.StringStringEntryProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a StringStringEntryProto {
  fn default() -> &'a StringStringEntryProto {
    <StringStringEntryProto as protobuf::Message>::default_instance()
  }
}

impl StringStringEntryProto {
  pub fn new() -> StringStringEntryProto {
    Default::default()
  }

  fn dispatch(&mut self, /*unused*/ _current_structure: &[String], structure_path: &[String], attribute_name: &str, /*unused*/ _integer_value: i32, /*unused*/ _float_value: f32, string_value: String, /*unused*/ _new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of string_string_entry_proto
      match attribute_name {
        "key" => self.set_key(string_value),
        "value" => self.set_value(string_value),
        "special_fields" => {}
        _ => panic!("STRINGSTRINGENTRYPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else {
      panic!("STRINGSTRINGENTRYPROTO dispatcher complex types not allowed!: {:?}", structure_path)
    }
  }

  // optional string key = 1;
  pub fn key(&self) -> &str {
    match self.key.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_key(&mut self) {
    self.key = None;
  }

  pub fn has_key(&self) -> bool {
    self.key.is_some()
  }

  // Param is passed by value, moved
  pub fn set_key(&mut self, v: String) {
    self.key = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_key(&mut self) -> &mut String {
    if self.key.is_none() {
      self.key = Some(String::new());
    }
    self.key.as_mut().unwrap()
  }

  // Take field
  pub fn take_key(&mut self) -> String {
    self.key.take().unwrap_or_else(|| String::new())
  }

  // optional string value = 2;

  pub fn value(&self) -> &str {
    match self.value.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_value(&mut self) {
    self.value = None;
  }

  pub fn has_value(&self) -> bool {
    self.value.is_some()
  }

  // Param is passed by value, moved
  pub fn set_value(&mut self, v: String) {
    self.value = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_value(&mut self) -> &mut String {
    if self.value.is_none() {
      self.value = Some(String::new());
    }
    self.value.as_mut().unwrap()
  }

  // Take field
  pub fn take_value(&mut self) -> String {
    self.value.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for StringStringEntryProto {
  const NAME: &'static str = "StringStringEntryProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.key = Some(is.read_string()?);
        }
        18 => {
          self.value = Some(is.read_string()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.key.as_ref() {
      os.write_string(1, v)?;
    }
    if let Some(v) = self.value.as_ref() {
      os.write_string(2, v)?;
    }
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.key.as_ref() {
      my_size += protobuf::rt::string_size(1, &v);
    }
    if let Some(v) = self.value.as_ref() {
      my_size += protobuf::rt::string_size(2, &v);
    }
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> StringStringEntryProto {
    StringStringEntryProto::new()
  }

  fn clear(&mut self) {
    self.key = None;
    self.value = None;
    self.special_fields.clear();
  }

  fn default_instance() -> &'static StringStringEntryProto {
    static instance: StringStringEntryProto = StringStringEntryProto {
      key: None,
      value: None,
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.TensorAnnotation)
pub struct TensorAnnotation {
  // message fields
  // @@protoc_insertion_point(field:onnx.TensorAnnotation.tensor_name)
  pub tensor_name: Option<String>,
  ///  <key, value> pairs to annotate tensor specified by <tensor_name> above.
  ///  The keys used in the mapping below must be pre-defined in ONNX spec.
  ///  For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
  ///  quantization parameter keys.
  // @@protoc_insertion_point(field:onnx.TensorAnnotation.quant_parameter_tensor_names)
  pub quant_parameter_tensor_names: Vec<StringStringEntryProto>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.TensorAnnotation.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a TensorAnnotation {
  fn default() -> &'a TensorAnnotation {
    <TensorAnnotation as protobuf::Message>::default_instance()
  }
}

impl TensorAnnotation {
  pub fn new() -> TensorAnnotation {
    Default::default()
  }

  // optional string tensor_name = 1;

  pub fn tensor_name(&self) -> &str {
    match self.tensor_name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_tensor_name(&mut self) {
    self.tensor_name = None;
  }

  pub fn has_tensor_name(&self) -> bool {
    self.tensor_name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_tensor_name(&mut self, v: String) {
    self.tensor_name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_tensor_name(&mut self) -> &mut String {
    if self.tensor_name.is_none() {
      self.tensor_name = Some(String::new());
    }
    self.tensor_name.as_mut().unwrap()
  }

  // Take field
  pub fn take_tensor_name(&mut self) -> String {
    self.tensor_name.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for TensorAnnotation {
  const NAME: &'static str = "TensorAnnotation";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.tensor_name = Some(is.read_string()?);
        }
        18 => {
          self.quant_parameter_tensor_names.push(is.read_message()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.tensor_name.as_ref() {
      os.write_string(1, v)?;
    }
    for v in &self.quant_parameter_tensor_names {
      protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
    };
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.tensor_name.as_ref() {
      my_size += protobuf::rt::string_size(1, &v);
    }
    for value in &self.quant_parameter_tensor_names {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> TensorAnnotation {
    TensorAnnotation::new()
  }

  fn clear(&mut self) {
    self.tensor_name = None;
    self.quant_parameter_tensor_names.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static TensorAnnotation {
    static instance: TensorAnnotation = TensorAnnotation {
      tensor_name: None,
      quant_parameter_tensor_names: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  Graphs
///
///  A graph defines the computational logic of a model and is comprised of a parameterized
///  list of nodes that form a directed acyclic graph based on their inputs and outputs.
///  This is the equivalent of the "network" or "graph" in many deep learning
///  frameworks.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.GraphProto)
pub struct GraphProto {
  // message fields
  ///  The nodes in the graph, sorted topologically.
  // @@protoc_insertion_point(field:onnx.GraphProto.node)
  pub node: Vec<NodeProto>,
  ///  The name of the graph.
  // @@protoc_insertion_point(field:onnx.GraphProto.name)
  pub name: Option<String>,
  ///  A list of named tensor values, used to specify constant inputs of the graph.
  ///  Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
  ///  The name MUST be unique across both initializer and sparse_initializer,
  ///  but the name MAY also appear in the input list.
  // @@protoc_insertion_point(field:onnx.GraphProto.initializer)
  pub initializer: Vec<TensorProto>,
  ///  Initializers (see above) stored in sparse format.
  // @@protoc_insertion_point(field:onnx.GraphProto.sparse_initializer)
  pub sparse_initializer: Vec<SparseTensorProto>,
  ///  A human-readable documentation for this graph. Markdown is allowed.
  // @@protoc_insertion_point(field:onnx.GraphProto.doc_string)
  pub doc_string: Option<String>,
  ///  The inputs and outputs of the graph.
  // @@protoc_insertion_point(field:onnx.GraphProto.input)
  pub input: Vec<ValueInfoProto>,
  // @@protoc_insertion_point(field:onnx.GraphProto.output)
  pub output: Vec<ValueInfoProto>,
  ///  Information for the values in the graph. The ValueInfoProto.name's
  ///  must be distinct. It is optional for a value to appear in value_info list.
  // @@protoc_insertion_point(field:onnx.GraphProto.value_info)
  pub value_info: Vec<ValueInfoProto>,
  ///  This field carries information to indicate the mapping among a tensor and its
  ///  quantization parameter tensors. For example:
  ///  For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
  ///  which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
  // @@protoc_insertion_point(field:onnx.GraphProto.quantization_annotation)
  pub quantization_annotation: Vec<TensorAnnotation>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.GraphProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a GraphProto {
  fn default() -> &'a GraphProto {
    <GraphProto as protobuf::Message>::default_instance()
  }
}

impl GraphProto {
  pub fn new() -> GraphProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of graph_proto
      match attribute_name {
        "name" => self.set_name(string_value),
        "doc_string" => self.set_doc_string(string_value),
        "special_fields" => {}
        _ => panic!("GRAPHPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "nodeproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.node.push(NodeProto::default());
            self.node.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.node.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "tensorproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.initializer.push(TensorProto::default());
            self.initializer.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.initializer.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "sparsetensorproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.sparse_initializer.push(SparseTensorProto::default());
            self.sparse_initializer.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.sparse_initializer.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "valueinfoproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            match attribute_name {
              "input" => {
                self.input.push(ValueInfoProto::default());
                self.input.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              "output" => {
                self.output.push(ValueInfoProto::default());
                self.output.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              "value_info" => {
                self.value_info.push(ValueInfoProto::default());
                self.value_info.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
              }
              _ => panic!("GRAPHPROTO -> valueinfoproto: attribute name Add cannot be done; it does not match any ValueInfoProto structure: {}", attribute_name)
            }
          } else {
            match current_structure_search(current_structure, structure_path.len()).as_str() {
              "input" => self.input.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              "output" => self.output.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              "value_info" => self.value_info.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
              _ => panic!("GRAPHPROTO -> valueinfoproto: attribute name Dispatch cannot be done; it does not match any ValueInfoProto structure: {}", current_structure_search(current_structure, structure_path.len()).as_str())
            }
          }
        }
        _ => panic!("GRAPHPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }

  // optional string name = 2;
  pub fn name(&self) -> &str {
    match self.name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_name(&mut self) {
    self.name = None;
  }

  pub fn has_name(&self) -> bool {
    self.name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_name(&mut self, v: String) {
    self.name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_name(&mut self) -> &mut String {
    if self.name.is_none() {
      self.name = Some(String::new());
    }
    self.name.as_mut().unwrap()
  }

  // Take field
  pub fn take_name(&mut self) -> String {
    self.name.take().unwrap_or_else(|| String::new())
  }

  // optional string doc_string = 10;

  pub fn doc_string(&self) -> &str {
    match self.doc_string.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_doc_string(&mut self) {
    self.doc_string = None;
  }

  pub fn has_doc_string(&self) -> bool {
    self.doc_string.is_some()
  }

  // Param is passed by value, moved
  pub fn set_doc_string(&mut self, v: String) {
    self.doc_string = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_doc_string(&mut self) -> &mut String {
    if self.doc_string.is_none() {
      self.doc_string = Some(String::new());
    }
    self.doc_string.as_mut().unwrap()
  }

  // Take field
  pub fn take_doc_string(&mut self) -> String {
    self.doc_string.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for GraphProto {
  const NAME: &'static str = "GraphProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.node.push(is.read_message()?);
        }
        18 => {
          self.name = Some(is.read_string()?);
        }
        42 => {
          self.initializer.push(is.read_message()?);
        }
        122 => {
          self.sparse_initializer.push(is.read_message()?);
        }
        82 => {
          self.doc_string = Some(is.read_string()?);
        }
        90 => {
          self.input.push(is.read_message()?);
        }
        98 => {
          self.output.push(is.read_message()?);
        }
        106 => {
          self.value_info.push(is.read_message()?);
        }
        114 => {
          self.quantization_annotation.push(is.read_message()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    for v in &self.node {
      protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
    };
    if let Some(v) = self.name.as_ref() {
      os.write_string(2, v)?;
    }
    for v in &self.initializer {
      protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
    };
    for v in &self.sparse_initializer {
      protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
    };
    if let Some(v) = self.doc_string.as_ref() {
      os.write_string(10, v)?;
    }
    for v in &self.input {
      protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
    };
    for v in &self.output {
      protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
    };
    for v in &self.value_info {
      protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
    };
    for v in &self.quantization_annotation {
      protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
    };
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    for value in &self.node {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    if let Some(v) = self.name.as_ref() {
      my_size += protobuf::rt::string_size(2, &v);
    }
    for value in &self.initializer {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.sparse_initializer {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    if let Some(v) = self.doc_string.as_ref() {
      my_size += protobuf::rt::string_size(10, &v);
    }
    for value in &self.input {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.output {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.value_info {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.quantization_annotation {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> GraphProto {
    GraphProto::new()
  }

  fn clear(&mut self) {
    self.node.clear();
    self.name = None;
    self.initializer.clear();
    self.sparse_initializer.clear();
    self.doc_string = None;
    self.input.clear();
    self.output.clear();
    self.value_info.clear();
    self.quantization_annotation.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static GraphProto {
    static instance: GraphProto = GraphProto {
      node: Vec::new(),
      name: None,
      initializer: Vec::new(),
      sparse_initializer: Vec::new(),
      doc_string: None,
      input: Vec::new(),
      output: Vec::new(),
      value_info: Vec::new(),
      quantization_annotation: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  Tensors
///
///  A serialized tensor value.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.TensorProto)
pub struct TensorProto {
  // message fields
  ///  The shape of the tensor.
  // @@protoc_insertion_point(field:onnx.TensorProto.dims)
  pub dims: Vec<i64>,
  ///  The data type of the tensor.
  ///  This field MUST have a valid TensorProto.DataType value
  // @@protoc_insertion_point(field:onnx.TensorProto.data_type)
  pub data_type: Option<i32>,
  // @@protoc_insertion_point(field:onnx.TensorProto.segment)
  pub segment: protobuf::MessageField<tensor_proto::Segment>,
  ///  For float and complex64 values
  ///  Complex64 tensors are encoded as a single array of floats,
  ///  with the real components appearing in odd numbered positions,
  ///  and the corresponding imaginary component appearing in the
  ///  subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  ///  is encoded as [1.0, 2.0 ,3.0 ,4.0]
  ///  When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
  // @@protoc_insertion_point(field:onnx.TensorProto.float_data)
  pub float_data: Vec<f32>,
  ///  For int32, uint8, int8, uint16, int16, bool, float8, and float16 values
  ///  float16 and float8 values must be bit-wise converted to an uint16_t prior
  ///  to writing to the buffer.
  ///  When this field is present, the data_type field MUST be
  ///  INT32, INT16, INT8, UINT16, UINT8, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ
  // @@protoc_insertion_point(field:onnx.TensorProto.int32_data)
  pub int32_data: Vec<i32>,
  ///  For strings.
  ///  Each element of string_data is a UTF-8 encoded Unicode
  ///  string. No trailing null, no leading BOM. The protobuf "string"
  ///  scalar type is not used to match ML community conventions.
  ///  When this field is present, the data_type field MUST be STRING
  // @@protoc_insertion_point(field:onnx.TensorProto.string_data)
  pub string_data: Vec<Vec<u8>>,
  ///  For int64.
  ///  When this field is present, the data_type field MUST be INT64
  // @@protoc_insertion_point(field:onnx.TensorProto.int64_data)
  pub int64_data: Vec<i64>,
  ///  Optionally, a name for the tensor.
  // @@protoc_insertion_point(field:onnx.TensorProto.name)
  pub name: Option<String>,
  ///  A human-readable documentation for this tensor. Markdown is allowed.
  // @@protoc_insertion_point(field:onnx.TensorProto.doc_string)
  pub doc_string: Option<String>,
  ///  Serializations can either use one of the fields above, or use this
  ///  raw bytes field. The only exception is the string case, where one is
  ///  required to store the content in the repeated bytes string_data field.
  ///
  ///  When this raw_data field is used to store tensor value, elements MUST
  ///  be stored in as fixed-width, little-endian order.
  ///  Floating-point data types MUST be stored in IEEE 754 format.
  ///  Complex64 elements must be written as two consecutive FLOAT values, real component first.
  ///  Complex128 elements must be written as two consecutive DOUBLE values, real component first.
  ///  Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
  ///
  ///  Note: the advantage of specific field rather than the raw_data field is
  ///  that in some cases (e.g. int data), protobuf does a better packing via
  ///  variable length storage, and may lead to smaller binary footprint.
  ///  When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
  // @@protoc_insertion_point(field:onnx.TensorProto.raw_data)
  pub raw_data: Option<Vec<u8>>,
  // @@protoc_insertion_point(field:onnx.TensorProto.external_data)
  pub external_data: Vec<StringStringEntryProto>,
  ///  If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
  // @@protoc_insertion_point(field:onnx.TensorProto.data_location)
  pub data_location: Option<protobuf::EnumOrUnknown<tensor_proto::DataLocation>>,
  ///  For double
  ///  Complex128 tensors are encoded as a single array of doubles,
  ///  with the real components appearing in odd numbered positions,
  ///  and the corresponding imaginary component appearing in the
  ///  subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  ///  is encoded as [1.0, 2.0 ,3.0 ,4.0]
  ///  When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
  // @@protoc_insertion_point(field:onnx.TensorProto.double_data)
  pub double_data: Vec<f64>,
  ///  For uint64 and uint32 values
  ///  When this field is present, the data_type field MUST be
  ///  UINT32 or UINT64
  // @@protoc_insertion_point(field:onnx.TensorProto.uint64_data)
  pub uint64_data: Vec<u64>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.TensorProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a TensorProto {
  fn default() -> &'a TensorProto {
    <TensorProto as protobuf::Message>::default_instance()
  }
}

impl TensorProto {
  pub fn new() -> TensorProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of tensor_proto
      match attribute_name {
        "dims" => self.dims.push(integer_value.into()),
        "data_type" => self.set_data_type(integer_value),
        "float_data" => {
          match self.data_type(){
            1 => {
              let aus: Vec<f32> = string_value
                .split(',')
                .map(|s| s.trim().parse::<f32>())
                .filter_map(Result::ok)
                .collect();
              self.float_data = aus;
            },
            _ => panic!("TENSORPROTO dispatcher float DATA TYPE not implemented: {}", self.data_type.unwrap())
          }
        },
        "int32_data" => self.int32_data.push(integer_value),
        "string_data" => self.string_data.push(Vec::from(string_value)),
        "int64_data" => {
          match self.data_type(){
            7 =>{
              let aus: Vec<i64> = string_value
                .split(',')
                .map(|s| s.trim().parse::<i64>())
                .filter_map(Result::ok)
                .collect();
              self.int64_data = aus;
            },
            _ => panic!("TENSORPROTO dispatcher i64 DATA TYPE not implemented: {}", self.data_type.unwrap())
          }
        },
        "name" => self.set_name(string_value),
        "doc_string" => self.set_doc_string(string_value),
        "raw_data" => {
          match self.data_type(){
            1 => {
              let aus: Vec<f32> = string_value
                .split(',')
                .map(|s| s.trim().parse::<f32>())
                .filter_map(Result::ok)
                .collect();
              let aus_u8: Vec<u8> = aus.iter()
                .flat_map(|&f| unsafe { std::mem::transmute::<f32, [u8; 4]>(f).to_vec() })
                .collect();
              self.set_raw_data(aus_u8);
            },
            7 => {
              let aus: Vec<i64> = string_value
                .split(',')
                .map(|s| s.trim().parse::<i64>())
                .filter_map(Result::ok)
                .collect();
              let aus_u8: Vec<u8> = aus.iter()
                .flat_map(|&f| unsafe { std::mem::transmute::<i64, [u8; 8]>(f).to_vec() })
                .collect();
              self.set_raw_data(aus_u8);
            },
            _ => panic!("TENSORPROTO dispatcher raw data DATA TYPE not implemented: {}", self.data_type.unwrap())
          }
          //printing raw_data as f32
          /*let mut i=0;
          while i < self.raw_data.clone().unwrap().len()-3{
            println!("{}", f32::from_le_bytes([self.raw_data.clone().unwrap()[i], self.raw_data.clone().unwrap()[i+1], self.raw_data.clone().unwrap()[i+2], self.raw_data.clone().unwrap()[i+3]]));
            i+=4;
          }*/
        }
        "double_data" => self.double_data.push(float_value.into()),
        "uint64_data" => self.uint64_data.push(integer_value as u64),
        "default" => self.data_location = Option::from(EnumOrUnknown::new(tensor_proto::DataLocation::DEFAULT)),
        "external" => self.data_location = Option::from(EnumOrUnknown::new(tensor_proto::DataLocation::EXTERNAL)),
        "special_fields" => {}
        _ => panic!("TENSORPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "segment" => self.segment.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
        "stringstringentryproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.external_data.push(StringStringEntryProto::default());
            self.external_data.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.external_data.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "datalocation" => {}
        _ => panic!("TENSORPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }

  // optional int32 data_type = 2;
  pub fn data_type(&self) -> i32 {
    self.data_type.unwrap_or(0)
  }

  pub fn clear_data_type(&mut self) {
    self.data_type = None;
  }

  pub fn has_data_type(&self) -> bool {
    self.data_type.is_some()
  }

  // Param is passed by value, moved
  pub fn set_data_type(&mut self, v: i32) {
    self.data_type = Some(v);
  }

  // optional string name = 8;

  pub fn name(&self) -> &str {
    match self.name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_name(&mut self) {
    self.name = None;
  }

  pub fn has_name(&self) -> bool {
    self.name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_name(&mut self, v: String) {
    self.name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_name(&mut self) -> &mut String {
    if self.name.is_none() {
      self.name = Some(String::new());
    }
    self.name.as_mut().unwrap()
  }

  // Take field
  pub fn take_name(&mut self) -> String {
    self.name.take().unwrap_or_else(|| String::new())
  }

  // optional string doc_string = 12;

  pub fn doc_string(&self) -> &str {
    match self.doc_string.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_doc_string(&mut self) {
    self.doc_string = None;
  }

  pub fn has_doc_string(&self) -> bool {
    self.doc_string.is_some()
  }

  // Param is passed by value, moved
  pub fn set_doc_string(&mut self, v: String) {
    self.doc_string = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_doc_string(&mut self) -> &mut String {
    if self.doc_string.is_none() {
      self.doc_string = Some(String::new());
    }
    self.doc_string.as_mut().unwrap()
  }

  // Take field
  pub fn take_doc_string(&mut self) -> String {
    self.doc_string.take().unwrap_or_else(|| String::new())
  }

  // optional bytes raw_data = 9;

  pub fn raw_data(&self) -> &[u8] {
    match self.raw_data.as_ref() {
      Some(v) => v,
      None => &[],
    }
  }

  pub fn clear_raw_data(&mut self) {
    self.raw_data = None;
  }

  pub fn has_raw_data(&self) -> bool {
    self.raw_data.is_some()
  }

  // Param is passed by value, moved
  pub fn set_raw_data(&mut self, v: Vec<u8>) {
    self.raw_data = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_raw_data(&mut self) -> &mut Vec<u8> {
    if self.raw_data.is_none() {
      self.raw_data = Some(Vec::new());
    }
    self.raw_data.as_mut().unwrap()
  }

  // Take field
  pub fn take_raw_data(&mut self) -> Vec<u8> {
    self.raw_data.take().unwrap_or_else(|| Vec::new())
  }

  // optional .onnx.TensorProto.DataLocation data_location = 14;

  pub fn data_location(&self) -> tensor_proto::DataLocation {
    match self.data_location {
      Some(e) => e.enum_value_or(tensor_proto::DataLocation::DEFAULT),
      None => tensor_proto::DataLocation::DEFAULT,
    }
  }

  pub fn clear_data_location(&mut self) {
    self.data_location = None;
  }

  pub fn has_data_location(&self) -> bool {
    self.data_location.is_some()
  }

  // Param is passed by value, moved
  pub fn set_data_location(&mut self, v: tensor_proto::DataLocation) {
    self.data_location = Some(protobuf::EnumOrUnknown::new(v));
  }
}

impl protobuf::Message for TensorProto {
  const NAME: &'static str = "TensorProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          is.read_repeated_packed_int64_into(&mut self.dims)?;
        }
        8 => {
          self.dims.push(is.read_int64()?);
        }
        16 => {
          self.data_type = Some(is.read_int32()?);
        }
        26 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.segment)?;
        }
        34 => {
          is.read_repeated_packed_float_into(&mut self.float_data)?;
        }
        37 => {
          self.float_data.push(is.read_float()?);
        }
        42 => {
          is.read_repeated_packed_int32_into(&mut self.int32_data)?;
        }
        40 => {
          self.int32_data.push(is.read_int32()?);
        }
        50 => {
          self.string_data.push(is.read_bytes()?);
        }
        58 => {
          is.read_repeated_packed_int64_into(&mut self.int64_data)?;
        }
        56 => {
          self.int64_data.push(is.read_int64()?);
        }
        66 => {
          self.name = Some(is.read_string()?);
        }
        98 => {
          self.doc_string = Some(is.read_string()?);
        }
        74 => {
          self.raw_data = Some(is.read_bytes()?);
        }
        106 => {
          self.external_data.push(is.read_message()?);
        }
        112 => {
          self.data_location = Some(is.read_enum_or_unknown()?);
        }
        82 => {
          is.read_repeated_packed_double_into(&mut self.double_data)?;
        }
        81 => {
          self.double_data.push(is.read_double()?);
        }
        90 => {
          is.read_repeated_packed_uint64_into(&mut self.uint64_data)?;
        }
        88 => {
          self.uint64_data.push(is.read_uint64()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    for v in &self.dims {
      os.write_int64(1, *v)?;
    };
    if let Some(v) = self.data_type {
      os.write_int32(2, v)?;
    }
    if let Some(v) = self.segment.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
    }
    os.write_repeated_packed_float(4, &self.float_data)?;
    os.write_repeated_packed_int32(5, &self.int32_data)?;
    for v in &self.string_data {
      os.write_bytes(6, &v)?;
    };
    os.write_repeated_packed_int64(7, &self.int64_data)?;
    if let Some(v) = self.name.as_ref() {
      os.write_string(8, v)?;
    }
    if let Some(v) = self.doc_string.as_ref() {
      os.write_string(12, v)?;
    }
    if let Some(v) = self.raw_data.as_ref() {
      os.write_bytes(9, v)?;
    }
    for v in &self.external_data {
      protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
    };
    if let Some(v) = self.data_location {
      os.write_enum(14, protobuf::EnumOrUnknown::value(&v))?;
    }
    os.write_repeated_packed_double(10, &self.double_data)?;
    os.write_repeated_packed_uint64(11, &self.uint64_data)?;
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    for value in &self.dims {
      my_size += protobuf::rt::int64_size(1, *value);
    };
    if let Some(v) = self.data_type {
      my_size += protobuf::rt::int32_size(2, v);
    }
    if let Some(v) = self.segment.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    my_size += protobuf::rt::vec_packed_float_size(4, &self.float_data);
    my_size += protobuf::rt::vec_packed_int32_size(5, &self.int32_data);
    for value in &self.string_data {
      my_size += protobuf::rt::bytes_size(6, &value);
    };
    my_size += protobuf::rt::vec_packed_int64_size(7, &self.int64_data);
    if let Some(v) = self.name.as_ref() {
      my_size += protobuf::rt::string_size(8, &v);
    }
    if let Some(v) = self.doc_string.as_ref() {
      my_size += protobuf::rt::string_size(12, &v);
    }
    if let Some(v) = self.raw_data.as_ref() {
      my_size += protobuf::rt::bytes_size(9, &v);
    }
    for value in &self.external_data {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    if let Some(v) = self.data_location {
      my_size += protobuf::rt::int32_size(14, v.value());
    }
    my_size += protobuf::rt::vec_packed_double_size(10, &self.double_data);
    my_size += protobuf::rt::vec_packed_uint64_size(11, &self.uint64_data);
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> TensorProto {
    TensorProto::new()
  }

  fn clear(&mut self) {
    self.dims.clear();
    self.data_type = None;
    self.segment.clear();
    self.float_data.clear();
    self.int32_data.clear();
    self.string_data.clear();
    self.int64_data.clear();
    self.name = None;
    self.doc_string = None;
    self.raw_data = None;
    self.external_data.clear();
    self.data_location = None;
    self.double_data.clear();
    self.uint64_data.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static TensorProto {
    static instance: TensorProto = TensorProto {
      dims: Vec::new(),
      data_type: None,
      segment: protobuf::MessageField::none(),
      float_data: Vec::new(),
      int32_data: Vec::new(),
      string_data: Vec::new(),
      int64_data: Vec::new(),
      name: None,
      doc_string: None,
      raw_data: None,
      external_data: Vec::new(),
      data_location: None,
      double_data: Vec::new(),
      uint64_data: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

/// Nested message and enums of message `TensorProto`
pub mod tensor_proto {
  ///  For very large tensors, we may want to store them in chunks, in which
  ///  case the following fields will specify the segment that is stored in
  ///  the current TensorProto.
  #[derive(PartialEq, Clone, Default, Debug)]
  // @@protoc_insertion_point(message:onnx.TensorProto.Segment)
  pub struct Segment {
    // message fields
    // @@protoc_insertion_point(field:onnx.TensorProto.Segment.begin)
    pub begin: Option<i64>,
    // @@protoc_insertion_point(field:onnx.TensorProto.Segment.end)
    pub end: Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TensorProto.Segment.special_fields)
    pub special_fields: protobuf::SpecialFields,
  }

  impl<'a> Default for &'a Segment {
    fn default() -> &'a Segment {
      <Segment as protobuf::Message>::default_instance()
    }
  }

  impl Segment {
    pub fn new() -> Segment {
      Default::default()
    }

    pub(crate) fn dispatch(&mut self, /*unused*/ _current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, /*unused*/ _float_value: f32, /*unused*/ _string_value: String, /*unused*/ _new_structure_to_add: bool) {
      if structure_path.is_empty() { //simple types, direct children of segment
        match attribute_name {
          "begin" => self.set_begin(integer_value.into()),
          "end" => self.set_end(integer_value.into()),
          "special_fields" => {}
          _ => panic!("SEGMENT dispatcher simple types, method not found: {}", attribute_name)
        }
      } else { //complex types, here starts the dispatch recursion.
        panic!("SEGMENT dispatcher complex types, no children allowed: {:?}", structure_path);
      }
    }

    // optional int64 begin = 1;
    pub fn begin(&self) -> i64 {
      self.begin.unwrap_or(0)
    }

    pub fn clear_begin(&mut self) {
      self.begin = None;
    }

    pub fn has_begin(&self) -> bool {
      self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: i64) {
      self.begin = Some(v);
    }

    // optional int64 end = 2;

    pub fn end(&self) -> i64 {
      self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
      self.end = None;
    }

    pub fn has_end(&self) -> bool {
      self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i64) {
      self.end = Some(v);
    }
  }

  impl protobuf::Message for Segment {
    const NAME: &'static str = "Segment";

    fn is_initialized(&self) -> bool {
      true
    }

    fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
      while let Some(tag) = is.read_raw_tag_or_eof()? {
        match tag {
          8 => {
            self.begin = Some(is.read_int64()?);
          }
          16 => {
            self.end = Some(is.read_int64()?);
          }
          tag => {
            protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
          }
        };
      }
      Ok(())
    }

    fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
      if let Some(v) = self.begin {
        os.write_int64(1, v)?;
      }
      if let Some(v) = self.end {
        os.write_int64(2, v)?;
      }
      os.write_unknown_fields(self.special_fields.unknown_fields())?;
      Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
      let mut my_size = 0;
      if let Some(v) = self.begin {
        my_size += protobuf::rt::int64_size(1, v);
      }
      if let Some(v) = self.end {
        my_size += protobuf::rt::int64_size(2, v);
      }
      my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
      self.special_fields.cached_size().set(my_size as u32);
      my_size
    }

    fn special_fields(&self) -> &protobuf::SpecialFields {
      &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
      &mut self.special_fields
    }

    fn new() -> Segment {
      Segment::new()
    }

    fn clear(&mut self) {
      self.begin = None;
      self.end = None;
      self.special_fields.clear();
    }

    fn default_instance() -> &'static Segment {
      static instance: Segment = Segment {
        begin: None,
        end: None,
        special_fields: protobuf::SpecialFields::new(),
      };
      &instance
    }
  }

  #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
  // @@protoc_insertion_point(enum:onnx.TensorProto.DataType)
  pub enum DataType {
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UNDEFINED)
    UNDEFINED = 0,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT)
    FLOAT = 1,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT8)
    UINT8 = 2,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT8)
    INT8 = 3,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT16)
    UINT16 = 4,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT16)
    INT16 = 5,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT32)
    INT32 = 6,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT64)
    INT64 = 7,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.STRING)
    STRING = 8,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.BOOL)
    BOOL = 9,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT16)
    FLOAT16 = 10,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.DOUBLE)
    DOUBLE = 11,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT32)
    UINT32 = 12,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT64)
    UINT64 = 13,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.COMPLEX64)
    COMPLEX64 = 14,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.COMPLEX128)
    COMPLEX128 = 15,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.BFLOAT16)
    BFLOAT16 = 16,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT8E4M3FN)
    FLOAT8E4M3FN = 17,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT8E4M3FNUZ)
    FLOAT8E4M3FNUZ = 18,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT8E5M2)
    FLOAT8E5M2 = 19,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT8E5M2FNUZ)
    FLOAT8E5M2FNUZ = 20,
  }

  impl protobuf::Enum for DataType {
    const NAME: &'static str = "DataType";

    fn value(&self) -> i32 {
      *self as i32
    }

    fn from_i32(value: i32) -> Option<DataType> {
      match value {
        0 => Some(DataType::UNDEFINED),
        1 => Some(DataType::FLOAT),
        2 => Some(DataType::UINT8),
        3 => Some(DataType::INT8),
        4 => Some(DataType::UINT16),
        5 => Some(DataType::INT16),
        6 => Some(DataType::INT32),
        7 => Some(DataType::INT64),
        8 => Some(DataType::STRING),
        9 => Some(DataType::BOOL),
        10 => Some(DataType::FLOAT16),
        11 => Some(DataType::DOUBLE),
        12 => Some(DataType::UINT32),
        13 => Some(DataType::UINT64),
        14 => Some(DataType::COMPLEX64),
        15 => Some(DataType::COMPLEX128),
        16 => Some(DataType::BFLOAT16),
        17 => Some(DataType::FLOAT8E4M3FN),
        18 => Some(DataType::FLOAT8E4M3FNUZ),
        19 => Some(DataType::FLOAT8E5M2),
        20 => Some(DataType::FLOAT8E5M2FNUZ),
        _ => None
      }
    }

    fn from_str(s: &str) -> Option<Self> {
      todo!()
    }

    const VALUES: &'static [DataType] = &[
      DataType::UNDEFINED,
      DataType::FLOAT,
      DataType::UINT8,
      DataType::INT8,
      DataType::UINT16,
      DataType::INT16,
      DataType::INT32,
      DataType::INT64,
      DataType::STRING,
      DataType::BOOL,
      DataType::FLOAT16,
      DataType::DOUBLE,
      DataType::UINT32,
      DataType::UINT64,
      DataType::COMPLEX64,
      DataType::COMPLEX128,
      DataType::BFLOAT16,
      DataType::FLOAT8E4M3FN,
      DataType::FLOAT8E4M3FNUZ,
      DataType::FLOAT8E5M2,
      DataType::FLOAT8E5M2FNUZ,
    ];
  }

  impl Default for DataType {
    fn default() -> Self {
      DataType::UNDEFINED
    }
  }


  ///  Location of the data for this tensor. MUST be one of:
  ///  - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
  ///  - EXTERNAL - data stored in an external location as described by external_data field.
  #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
  // @@protoc_insertion_point(enum:onnx.TensorProto.DataLocation)
  pub enum DataLocation {
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataLocation.DEFAULT)
    DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataLocation.EXTERNAL)
    EXTERNAL = 1,
  }

  impl protobuf::Enum for DataLocation {
    const NAME: &'static str = "DataLocation";

    fn value(&self) -> i32 {
      *self as i32
    }

    fn from_i32(value: i32) -> Option<DataLocation> {
      match value {
        0 => Some(DataLocation::DEFAULT),
        1 => Some(DataLocation::EXTERNAL),
        _ => None
      }
    }

    fn from_str(s: &str) -> Option<Self> {
      todo!()
    }

    const VALUES: &'static [DataLocation] = &[
      DataLocation::DEFAULT,
      DataLocation::EXTERNAL,
    ];
  }

  impl Default for DataLocation {
    fn default() -> Self {
      DataLocation::DEFAULT
    }
  }
}

///  A serialized sparse-tensor value
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.SparseTensorProto)
pub struct SparseTensorProto {
  // message fields
  ///  The sequence of non-default values are encoded as a tensor of shape [NNZ].
  ///  The default-value is zero for numeric tensors, and empty-string for string tensors.
  ///  values must have a non-empty name present which serves as a name for SparseTensorProto
  ///  when used in sparse_initializer list.
  // @@protoc_insertion_point(field:onnx.SparseTensorProto.values)
  pub values: protobuf::MessageField<TensorProto>,
  ///  The indices of the non-default values, which may be stored in one of two formats.
  ///  (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
  ///  corresponding to the j-th index of the i-th value (in the values tensor).
  ///  (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
  ///  must be the linearized-index of the i-th value (in the values tensor).
  ///  The linearized-index can be converted into an index tuple (k_1,...,k_rank)
  ///  using the shape provided below.
  ///  The indices must appear in ascending order without duplication.
  ///  In the first format, the ordering is lexicographic-ordering:
  ///  e.g., index-value [1,4] must appear before [2,1]
  // @@protoc_insertion_point(field:onnx.SparseTensorProto.indices)
  pub indices: protobuf::MessageField<TensorProto>,
  ///  The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
  // @@protoc_insertion_point(field:onnx.SparseTensorProto.dims)
  pub dims: Vec<i64>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.SparseTensorProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a SparseTensorProto {
  fn default() -> &'a SparseTensorProto {
    <SparseTensorProto as protobuf::Message>::default_instance()
  }
}

impl SparseTensorProto {
  pub fn new() -> SparseTensorProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of sparse_tensor_proto
      match attribute_name {
        "dims" => self.dims.push(integer_value.into()),
        "special_fields" => {}
        _ => panic!("SPARSETENSORPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "tensorproto" => {
          match attribute_name {
            "values" => self.values.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
            "indices" => self.indices.as_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
            _ => panic!("SPARSETENSORPROTO -> tensorproto: attribute name Dispatch cannot be done; it does not match any TensorProto structure: {}", attribute_name)
          }
        }
        _ => panic!("SPARSETENSORPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }
}

impl protobuf::Message for SparseTensorProto {
  const NAME: &'static str = "SparseTensorProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.values)?;
        }
        18 => {
          protobuf::rt::read_singular_message_into_field(is, &mut self.indices)?;
        }
        26 => {
          is.read_repeated_packed_int64_into(&mut self.dims)?;
        }
        24 => {
          self.dims.push(is.read_int64()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.values.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
    }
    if let Some(v) = self.indices.as_ref() {
      protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
    }
    for v in &self.dims {
      os.write_int64(3, *v)?;
    };
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.values.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    if let Some(v) = self.indices.as_ref() {
      let len = v.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    }
    for value in &self.dims {
      my_size += protobuf::rt::int64_size(3, *value);
    };
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> SparseTensorProto {
    SparseTensorProto::new()
  }

  fn clear(&mut self) {
    self.values.clear();
    self.indices.clear();
    self.dims.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static SparseTensorProto {
    static instance: SparseTensorProto = SparseTensorProto {
      values: protobuf::MessageField::none(),
      indices: protobuf::MessageField::none(),
      dims: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  Defines a tensor shape. A dimension can be either an integer value
///  or a symbolic variable. A symbolic variable represents an unknown
///  dimension.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.TensorShapeProto)
pub struct TensorShapeProto {
  // message fields
  // @@protoc_insertion_point(field:onnx.TensorShapeProto.dim)
  pub dim: Vec<tensor_shape_proto::Dimension>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.TensorShapeProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a TensorShapeProto {
  fn default() -> &'a TensorShapeProto {
    <TensorShapeProto as protobuf::Message>::default_instance()
  }
}

impl TensorShapeProto {
  pub fn new() -> TensorShapeProto {
    Default::default()
  }

  pub(crate) fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of tensor_shape_proto
      match attribute_name {
        "special_fields" => {}
        _ => panic!("TENSORSHAPEPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "dimension" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.dim.push(tensor_shape_proto::Dimension::default());
            self.dim.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.dim.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        _ => panic!("TENSORSHAPEPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }
}

impl protobuf::Message for TensorShapeProto {
  const NAME: &'static str = "TensorShapeProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.dim.push(is.read_message()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    for v in &self.dim {
      protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
    };
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    for value in &self.dim {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> TensorShapeProto {
    TensorShapeProto::new()
  }

  fn clear(&mut self) {
    self.dim.clear();
    self.special_fields.clear();
  }

  fn default_instance() -> &'static TensorShapeProto {
    static instance: TensorShapeProto = TensorShapeProto {
      dim: Vec::new(),
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

/// Nested message and enums of message `TensorShapeProto`
pub mod tensor_shape_proto {
  #[derive(PartialEq, Clone, Default, Debug)]
  // @@protoc_insertion_point(message:onnx.TensorShapeProto.Dimension)
  pub struct Dimension {
    // message fields
    ///  Standard denotation can optionally be used to denote tensor
    ///  dimensions with standard semantic descriptions to ensure
    ///  that operations are applied to the correct axis of a tensor.
    ///  Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
    ///  for pre-defined dimension denotations.
    // @@protoc_insertion_point(field:onnx.TensorShapeProto.Dimension.denotation)
    pub denotation: Option<String>,
    // message oneof groups
    pub value: Option<dimension::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TensorShapeProto.Dimension.special_fields)
    pub special_fields: protobuf::SpecialFields,
  }

  impl<'a> Default for &'a Dimension {
    fn default() -> &'a Dimension {
      <Dimension as protobuf::Message>::default_instance()
    }
  }

  impl Dimension {
    pub fn new() -> Dimension {
      Default::default()
    }

    pub(crate) fn dispatch(&mut self, /*unused*/ _current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, /*unused*/ _float_value: f32, string_value: String, /*unused*/ _new_structure_to_add: bool) {
      if structure_path.is_empty() { //simple types, direct children of dimension
        match attribute_name {
          "denotation" => self.set_denotation(string_value),
          "dim_value" => self.value = Option::from(dimension::Value::DimValue(integer_value.into())),
          "dim_param" => self.value = Option::from(dimension::Value::DimParam(string_value)),
          "special_fields" => {}
          _ => panic!("TENSORSHAPEPROTO::DIMENSION dispatcher simple types, method not found: {}", attribute_name)
        }
      } else { //complex types, here starts the dispatch recursion.
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "value" => {}
          _ => panic!("TENSORSHAPEPROTO::DIMENSION dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      }
    }

    // optional int64 dim_value = 1;
    pub fn dim_value(&self) -> i64 {
      match self.value {
        Some(dimension::Value::DimValue(v)) => v,
        _ => 0,
      }
    }

    pub fn clear_dim_value(&mut self) {
      self.value = None;
    }

    pub fn has_dim_value(&self) -> bool {
      match self.value {
        Some(dimension::Value::DimValue(..)) => true,
        _ => false,
      }
    }

    // Param is passed by value, moved
    pub fn set_dim_value(&mut self, v: i64) {
      self.value = Some(dimension::Value::DimValue(v))
    }

    // optional string dim_param = 2;

    pub fn dim_param(&self) -> &str {
      match self.value {
        Some(dimension::Value::DimParam(ref v)) => v,
        _ => "",
      }
    }

    pub fn clear_dim_param(&mut self) {
      self.value = None;
    }

    pub fn has_dim_param(&self) -> bool {
      match self.value {
        Some(dimension::Value::DimParam(..)) => true,
        _ => false,
      }
    }

    // Param is passed by value, moved
    pub fn set_dim_param(&mut self, v: String) {
      self.value = Some(dimension::Value::DimParam(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dim_param(&mut self) -> &mut String {
      if let Some(dimension::Value::DimParam(_)) = self.value {} else {
        self.value = Some(dimension::Value::DimParam(String::new()));
      }
      match self.value {
        Some(dimension::Value::DimParam(ref mut v)) => v,
        _ => panic!(),
      }
    }

    // Take field
    pub fn take_dim_param(&mut self) -> String {
      if self.has_dim_param() {
        match self.value.take() {
          Some(dimension::Value::DimParam(v)) => v,
          _ => panic!(),
        }
      } else {
        String::new()
      }
    }

    // optional string denotation = 3;

    pub fn denotation(&self) -> &str {
      match self.denotation.as_ref() {
        Some(v) => v,
        None => "",
      }
    }

    pub fn clear_denotation(&mut self) {
      self.denotation = None;
    }

    pub fn has_denotation(&self) -> bool {
      self.denotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denotation(&mut self, v: String) {
      self.denotation = Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denotation(&mut self) -> &mut String {
      if self.denotation.is_none() {
        self.denotation = Some(String::new());
      }
      self.denotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_denotation(&mut self) -> String {
      self.denotation.take().unwrap_or_else(|| String::new())
    }
  }

  impl protobuf::Message for Dimension {
    const NAME: &'static str = "Dimension";

    fn is_initialized(&self) -> bool {
      true
    }

    fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
      while let Some(tag) = is.read_raw_tag_or_eof()? {
        match tag {
          8 => {
            self.value = Some(dimension::Value::DimValue(is.read_int64()?));
          }
          18 => {
            self.value = Some(dimension::Value::DimParam(is.read_string()?));
          }
          26 => {
            self.denotation = Some(is.read_string()?);
          }
          tag => {
            protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
          }
        };
      }
      Ok(())
    }

    fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
      if let Some(v) = self.denotation.as_ref() {
        os.write_string(3, v)?;
      }
      if let Some(ref v) = self.value {
        match v {
          &dimension::Value::DimValue(v) => {
            os.write_int64(1, v)?;
          }
          &dimension::Value::DimParam(ref v) => {
            os.write_string(2, v)?;
          }
        };
      }
      os.write_unknown_fields(self.special_fields.unknown_fields())?;
      Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
      let mut my_size = 0;
      if let Some(v) = self.denotation.as_ref() {
        my_size += protobuf::rt::string_size(3, &v);
      }
      if let Some(ref v) = self.value {
        match v {
          &dimension::Value::DimValue(v) => {
            my_size += protobuf::rt::int64_size(1, v);
          }
          &dimension::Value::DimParam(ref v) => {
            my_size += protobuf::rt::string_size(2, &v);
          }
        };
      }
      my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
      self.special_fields.cached_size().set(my_size as u32);
      my_size
    }

    fn special_fields(&self) -> &protobuf::SpecialFields {
      &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
      &mut self.special_fields
    }

    fn new() -> Dimension {
      Dimension::new()
    }

    fn clear(&mut self) {
      self.value = None;
      self.value = None;
      self.denotation = None;
      self.special_fields.clear();
    }

    fn default_instance() -> &'static Dimension {
      static instance: Dimension = Dimension {
        denotation: None,
        value: None,
        special_fields: protobuf::SpecialFields::new(),
      };
      &instance
    }
  }

  /// Nested message and enums of message `Dimension`
  pub mod dimension {
    #[derive(Clone, PartialEq, Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:onnx.TensorShapeProto.Dimension.value)
    pub enum Value {
      // @@protoc_insertion_point(oneof_field:onnx.TensorShapeProto.Dimension.dim_value)
      DimValue(i64),
      // @@protoc_insertion_point(oneof_field:onnx.TensorShapeProto.Dimension.dim_param)
      DimParam(String),
    }

    impl protobuf::Oneof for Value {}

    impl Value {}
  }
}

///  Types
///
///  The standard ONNX data types.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.TypeProto)
pub struct TypeProto {
  // message fields
  ///  An optional denotation can be used to denote the whole
  ///  type with a standard semantic description as to what is
  ///  stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
  ///  for pre-defined type denotations.
  // @@protoc_insertion_point(field:onnx.TypeProto.denotation)
  pub denotation: Option<String>,
  // message oneof groups
  pub value: Option<type_proto::Value>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.TypeProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a TypeProto {
  fn default() -> &'a TypeProto {
    <TypeProto as protobuf::Message>::default_instance()
  }
}

impl TypeProto {
  pub fn new() -> TypeProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of type_proto
      match attribute_name {
        "denotation" => self.set_denotation(string_value),
        "special_fields" => {}
        _ => panic!("TYPEPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      if (new_structure_to_add && structure_path.len() != 1) || !new_structure_to_add {
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "value" => {}
          "tensor" => self.mut_tensor_type().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
          "sequence" => self.mut_sequence_type().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
          "map" => self.mut_map_type().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
          "optional" => self.mut_optional_type().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
          "sparsetensor" => self.mut_sparse_tensor_type().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add),
          _ => panic!("TYPEPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      } else {
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "value" => {}
          "tensor" => self.mut_tensor_type().special_fields.cached_size().set(integer_value as u32),
          "sequence" => self.mut_sequence_type().special_fields.cached_size().set(integer_value as u32),
          "map" => self.mut_map_type().special_fields.cached_size().set(integer_value as u32),
          "optional" => self.mut_optional_type().special_fields.cached_size().set(integer_value as u32),
          "sparsetensor" => self.mut_sparse_tensor_type().special_fields.cached_size().set(integer_value as u32),
          _ => panic!("TYPEPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      }
    }
  }

  // optional .onnx.TypeProto.Tensor tensor_type = 1;
  pub fn tensor_type(&self) -> &type_proto::Tensor {
    match self.value {
      Some(type_proto::Value::TensorType(ref v)) => v,
      _ => <type_proto::Tensor as protobuf::Message>::default_instance(),
    }
  }

  pub fn clear_tensor_type(&mut self) {
    self.value = None;
  }

  pub fn has_tensor_type(&self) -> bool {
    match self.value {
      Some(type_proto::Value::TensorType(..)) => true,
      _ => false,
    }
  }

  // Param is passed by value, moved
  pub fn set_tensor_type(&mut self, v: type_proto::Tensor) {
    self.value = Some(type_proto::Value::TensorType(v))
  }

  // Mutable pointer to the field.
  pub fn mut_tensor_type(&mut self) -> &mut type_proto::Tensor {
    if let Some(type_proto::Value::TensorType(_)) = self.value {} else {
      self.value = Some(type_proto::Value::TensorType(type_proto::Tensor::new()));
    }
    match self.value {
      Some(type_proto::Value::TensorType(ref mut v)) => v,
      _ => panic!(),
    }
  }

  // Take field
  pub fn take_tensor_type(&mut self) -> Option<type_proto::Tensor> {
    if self.has_tensor_type() {
      match self.value.take() {
        Some(type_proto::Value::TensorType(v)) => Some(v),
        _ => panic!(),
      }
    } else {
      None
    }
  }

  // optional .onnx.TypeProto.Sequence sequence_type = 4;
  pub fn sequence_type(&self) -> &type_proto::Sequence {
    match self.value {
      Some(type_proto::Value::SequenceType(ref v)) => v,
      _ => <type_proto::Sequence as protobuf::Message>::default_instance(),
    }
  }

  pub fn clear_sequence_type(&mut self) {
    self.value = None;
  }

  pub fn has_sequence_type(&self) -> bool {
    match self.value {
      Some(type_proto::Value::SequenceType(..)) => true,
      _ => false,
    }
  }

  // Param is passed by value, moved
  pub fn set_sequence_type(&mut self, v: type_proto::Sequence) {
    self.value = Some(type_proto::Value::SequenceType(v))
  }

  // Mutable pointer to the field.
  pub fn mut_sequence_type(&mut self) -> &mut type_proto::Sequence {
    if let Some(type_proto::Value::SequenceType(_)) = self.value {} else {
      self.value = Some(type_proto::Value::SequenceType(type_proto::Sequence::new()));
    }
    match self.value {
      Some(type_proto::Value::SequenceType(ref mut v)) => v,
      _ => panic!(),
    }
  }

  // Take field
  pub fn take_sequence_type(&mut self) -> Option<type_proto::Sequence> {
    if self.has_sequence_type() {
      match self.value.take() {
        Some(type_proto::Value::SequenceType(v)) => Some(v),
        _ => panic!(),
      }
    } else {
      None
    }
  }

  // optional .onnx.TypeProto.Map map_type = 5;
  pub fn map_type(&self) -> &type_proto::Map {
    match self.value {
      Some(type_proto::Value::MapType(ref v)) => v,
      _ => <type_proto::Map as protobuf::Message>::default_instance(),
    }
  }

  pub fn clear_map_type(&mut self) {
    self.value = None;
  }

  pub fn has_map_type(&self) -> bool {
    match self.value {
      Some(type_proto::Value::MapType(..)) => true,
      _ => false,
    }
  }

  // Param is passed by value, moved
  pub fn set_map_type(&mut self, v: type_proto::Map) {
    self.value = Some(type_proto::Value::MapType(v))
  }

  // Mutable pointer to the field.
  pub fn mut_map_type(&mut self) -> &mut type_proto::Map {
    if let Some(type_proto::Value::MapType(_)) = self.value {} else {
      self.value = Some(type_proto::Value::MapType(type_proto::Map::new()));
    }
    match self.value {
      Some(type_proto::Value::MapType(ref mut v)) => v,
      _ => panic!(),
    }
  }

  // Take field
  pub fn take_map_type(&mut self) -> Option<type_proto::Map> {
    if self.has_map_type() {
      match self.value.take() {
        Some(type_proto::Value::MapType(v)) => Some(v),
        _ => panic!(),
      }
    } else {
      None
    }
  }

  // optional .onnx.TypeProto.Optional optional_type = 9;
  pub fn optional_type(&self) -> &type_proto::Optional {
    match self.value {
      Some(type_proto::Value::OptionalType(ref v)) => v,
      _ => <type_proto::Optional as protobuf::Message>::default_instance(),
    }
  }

  pub fn clear_optional_type(&mut self) {
    self.value = None;
  }

  pub fn has_optional_type(&self) -> bool {
    match self.value {
      Some(type_proto::Value::OptionalType(..)) => true,
      _ => false,
    }
  }

  // Param is passed by value, moved
  pub fn set_optional_type(&mut self, v: type_proto::Optional) {
    self.value = Some(type_proto::Value::OptionalType(v))
  }

  // Mutable pointer to the field.
  pub fn mut_optional_type(&mut self) -> &mut type_proto::Optional {
    if let Some(type_proto::Value::OptionalType(_)) = self.value {} else {
      self.value = Some(type_proto::Value::OptionalType(type_proto::Optional::new()));
    }
    match self.value {
      Some(type_proto::Value::OptionalType(ref mut v)) => v,
      _ => panic!(),
    }
  }

  // Take field
  pub fn take_optional_type(&mut self) -> Option<type_proto::Optional> {
    if self.has_optional_type() {
      match self.value.take() {
        Some(type_proto::Value::OptionalType(v)) => Some(v),
        _ => panic!(),
      }
    } else {
      None
    }
  }

  // optional .onnx.TypeProto.SparseTensor sparse_tensor_type = 8;
  pub fn sparse_tensor_type(&self) -> &type_proto::SparseTensor {
    match self.value {
      Some(type_proto::Value::SparseTensorType(ref v)) => v,
      _ => <type_proto::SparseTensor as protobuf::Message>::default_instance(),
    }
  }

  pub fn clear_sparse_tensor_type(&mut self) {
    self.value = None;
  }

  pub fn has_sparse_tensor_type(&self) -> bool {
    match self.value {
      Some(type_proto::Value::SparseTensorType(..)) => true,
      _ => false,
    }
  }

  // Param is passed by value, moved
  pub fn set_sparse_tensor_type(&mut self, v: type_proto::SparseTensor) {
    self.value = Some(type_proto::Value::SparseTensorType(v))
  }

  // Mutable pointer to the field.
  pub fn mut_sparse_tensor_type(&mut self) -> &mut type_proto::SparseTensor {
    if let Some(type_proto::Value::SparseTensorType(_)) = self.value {} else {
      self.value = Some(type_proto::Value::SparseTensorType(type_proto::SparseTensor::new()));
    }
    match self.value {
      Some(type_proto::Value::SparseTensorType(ref mut v)) => v,
      _ => panic!(),
    }
  }

  // Take field
  pub fn take_sparse_tensor_type(&mut self) -> Option<type_proto::SparseTensor> {
    if self.has_sparse_tensor_type() {
      match self.value.take() {
        Some(type_proto::Value::SparseTensorType(v)) => Some(v),
        _ => panic!(),
      }
    } else {
      None
    }
  }

  // optional string denotation = 6;
  pub fn denotation(&self) -> &str {
    match self.denotation.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_denotation(&mut self) {
    self.denotation = None;
  }

  pub fn has_denotation(&self) -> bool {
    self.denotation.is_some()
  }

  // Param is passed by value, moved
  pub fn set_denotation(&mut self, v: String) {
    self.denotation = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_denotation(&mut self) -> &mut String {
    if self.denotation.is_none() {
      self.denotation = Some(String::new());
    }
    self.denotation.as_mut().unwrap()
  }

  // Take field
  pub fn take_denotation(&mut self) -> String {
    self.denotation.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for TypeProto {
  const NAME: &'static str = "TypeProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.value = Some(type_proto::Value::TensorType(is.read_message()?));
        }
        34 => {
          self.value = Some(type_proto::Value::SequenceType(is.read_message()?));
        }
        42 => {
          self.value = Some(type_proto::Value::MapType(is.read_message()?));
        }
        74 => {
          self.value = Some(type_proto::Value::OptionalType(is.read_message()?));
        }
        66 => {
          self.value = Some(type_proto::Value::SparseTensorType(is.read_message()?));
        }
        50 => {
          self.denotation = Some(is.read_string()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.denotation.as_ref() {
      os.write_string(6, v)?;
    }
    if let Some(ref v) = self.value {
      match v {
        &type_proto::Value::TensorType(ref v) => {
          protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        &type_proto::Value::SequenceType(ref v) => {
          protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        &type_proto::Value::MapType(ref v) => {
          protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        &type_proto::Value::OptionalType(ref v) => {
          protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        &type_proto::Value::SparseTensorType(ref v) => {
          protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
      };
    }
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.denotation.as_ref() {
      my_size += protobuf::rt::string_size(6, &v);
    }
    if let Some(ref v) = self.value {
      match v {
        &type_proto::Value::TensorType(ref v) => {
          let len = v.compute_size();
          my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        &type_proto::Value::SequenceType(ref v) => {
          let len = v.compute_size();
          my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        &type_proto::Value::MapType(ref v) => {
          let len = v.compute_size();
          my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        &type_proto::Value::OptionalType(ref v) => {
          let len = v.compute_size();
          my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        &type_proto::Value::SparseTensorType(ref v) => {
          let len = v.compute_size();
          my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
        }
      };
    }
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> TypeProto {
    TypeProto::new()
  }

  fn clear(&mut self) {
    self.value = None;
    self.value = None;
    self.value = None;
    self.value = None;
    self.value = None;
    self.denotation = None;
    self.special_fields.clear();
  }

  fn default_instance() -> &'static TypeProto {
    static instance: TypeProto = TypeProto {
      denotation: None,
      value: None,
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

/// Nested message and enums of message `TypeProto`
pub mod type_proto {
  #[derive(Clone, PartialEq, Debug)]
  #[non_exhaustive]
  // @@protoc_insertion_point(oneof:onnx.TypeProto.value)
  pub enum Value {
    // @@protoc_insertion_point(oneof_field:onnx.TypeProto.tensor_type)
    TensorType(Tensor),
    // @@protoc_insertion_point(oneof_field:onnx.TypeProto.sequence_type)
    SequenceType(Sequence),
    // @@protoc_insertion_point(oneof_field:onnx.TypeProto.map_type)
    MapType(Map),
    // @@protoc_insertion_point(oneof_field:onnx.TypeProto.optional_type)
    OptionalType(Optional),
    // @@protoc_insertion_point(oneof_field:onnx.TypeProto.sparse_tensor_type)
    SparseTensorType(SparseTensor),
  }

  impl protobuf::Oneof for Value {}

  impl Value {}

  #[derive(PartialEq, Clone, Default, Debug)]
  // @@protoc_insertion_point(message:onnx.TypeProto.Tensor)
  pub struct Tensor {
    // message fields
    ///  This field MUST NOT have the value of UNDEFINED
    ///  This field MUST have a valid TensorProto.DataType value
    ///  This field MUST be present for this version of the IR.
    // @@protoc_insertion_point(field:onnx.TypeProto.Tensor.elem_type)
    pub elem_type: Option<i32>,
    // @@protoc_insertion_point(field:onnx.TypeProto.Tensor.shape)
    pub shape: protobuf::MessageField<super::TensorShapeProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TypeProto.Tensor.special_fields)
    pub special_fields: protobuf::SpecialFields,
  }

  impl<'a> Default for &'a Tensor {
    fn default() -> &'a Tensor {
      <Tensor as protobuf::Message>::default_instance()
    }
  }

  impl Tensor {
    pub fn new() -> Tensor {
      Default::default()
    }

    pub(crate) fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
      if structure_path.is_empty() { //simple types, direct children of tensor
        match attribute_name {
          "elem_type" => self.set_elem_type(integer_value),
          "special_fields" => {}
          _ => panic!("TYPE::TENSOR dispatcher simple types, method not found: {}", attribute_name)
        }
      } else { //complex types, here starts the dispatch recursion.
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "tensorshapeproto" => {
            match self.shape.as_mut() {
              None => {
                self.shape = protobuf::MessageField::some(super::TensorShapeProto::new());
                match self.shape.as_mut() {
                  None => { panic!("TYPE::TENSOR dispatcher, cannot insert len"); }
                  Some(s) => { s.special_fields.cached_size().set(integer_value as u32); }
                }
              }
              Some(s) => s.dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add)
            }
          }
          _ => panic!("TYPE::TENSOR dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      }
    }

    // optional int32 elem_type = 1;
    pub fn elem_type(&self) -> i32 {
      self.elem_type.unwrap_or(0)
    }

    pub fn clear_elem_type(&mut self) {
      self.elem_type = None;
    }

    pub fn has_elem_type(&self) -> bool {
      self.elem_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: i32) {
      self.elem_type = Some(v);
    }
  }

  impl protobuf::Message for Tensor {
    const NAME: &'static str = "Tensor";

    fn is_initialized(&self) -> bool {
      true
    }

    fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
      while let Some(tag) = is.read_raw_tag_or_eof()? {
        match tag {
          8 => {
            self.elem_type = Some(is.read_int32()?);
          }
          18 => {
            protobuf::rt::read_singular_message_into_field(is, &mut self.shape)?;
          }
          tag => {
            protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
          }
        };
      }
      Ok(())
    }

    fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
      if let Some(v) = self.elem_type {
        os.write_int32(1, v)?;
      }
      if let Some(v) = self.shape.as_ref() {
        protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
      }
      os.write_unknown_fields(self.special_fields.unknown_fields())?;
      Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
      let mut my_size = 0;
      if let Some(v) = self.elem_type {
        my_size += protobuf::rt::int32_size(1, v);
      }
      if let Some(v) = self.shape.as_ref() {
        let len = v.compute_size();
        my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
      }
      my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
      self.special_fields.cached_size().set(my_size as u32);
      my_size
    }

    fn special_fields(&self) -> &protobuf::SpecialFields {
      &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
      &mut self.special_fields
    }

    fn new() -> Tensor {
      Tensor::new()
    }

    fn clear(&mut self) {
      self.elem_type = None;
      self.shape.clear();
      self.special_fields.clear();
    }

    fn default_instance() -> &'static Tensor {
      static instance: Tensor = Tensor {
        elem_type: None,
        shape: protobuf::MessageField::none(),
        special_fields: protobuf::SpecialFields::new(),
      };
      &instance
    }
  }

  ///  repeated T
  #[derive(PartialEq, Clone, Default, Debug)]
  // @@protoc_insertion_point(message:onnx.TypeProto.Sequence)
  pub struct Sequence {
    // message fields
    ///  The type and optional shape of each element of the sequence.
    ///  This field MUST be present for this version of the IR.
    // @@protoc_insertion_point(field:onnx.TypeProto.Sequence.elem_type)
    pub elem_type: protobuf::MessageField<super::TypeProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TypeProto.Sequence.special_fields)
    pub special_fields: protobuf::SpecialFields,
  }

  impl<'a> Default for &'a Sequence {
    fn default() -> &'a Sequence {
      <Sequence as protobuf::Message>::default_instance()
    }
  }

  impl Sequence {
    pub fn new() -> Sequence {
      Default::default()
    }
    pub(crate) fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
      if structure_path.is_empty() { //simple types, direct children of sequence
        match attribute_name {
          "special_fields" => {}
          _ => panic!("TYPE::SEQUENCE dispatcher simple types, method not found: {}", attribute_name)
        }
      } else { //complex types, here starts the dispatch recursion.
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "typeproto" => {
            match self.elem_type.as_mut() {
              None => {
                self.elem_type = protobuf::MessageField::some(super::TypeProto::new());
                match self.elem_type.as_mut() {
                  None => { panic!("TYPE::SEQUENCE dispatcher, cannot insert len"); }
                  Some(e) => { e.special_fields.cached_size().set(integer_value as u32); }
                }
              }
              Some(e) => e.dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add)
            }
          }
          _ => panic!("TYPE::SEQUENCE dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      }
    }
  }

  impl protobuf::Message for Sequence {
    const NAME: &'static str = "Sequence";

    fn is_initialized(&self) -> bool {
      true
    }

    fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
      while let Some(tag) = is.read_raw_tag_or_eof()? {
        match tag {
          10 => {
            protobuf::rt::read_singular_message_into_field(is, &mut self.elem_type)?;
          }
          tag => {
            protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
          }
        };
      }
      Ok(())
    }

    fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
      if let Some(v) = self.elem_type.as_ref() {
        protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
      }
      os.write_unknown_fields(self.special_fields.unknown_fields())?;
      Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
      let mut my_size = 0;
      if let Some(v) = self.elem_type.as_ref() {
        let len = v.compute_size();
        my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
      }
      my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
      self.special_fields.cached_size().set(my_size as u32);
      my_size
    }

    fn special_fields(&self) -> &protobuf::SpecialFields {
      &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
      &mut self.special_fields
    }

    fn new() -> Sequence {
      Sequence::new()
    }

    fn clear(&mut self) {
      self.elem_type.clear();
      self.special_fields.clear();
    }

    fn default_instance() -> &'static Sequence {
      static instance: Sequence = Sequence {
        elem_type: protobuf::MessageField::none(),
        special_fields: protobuf::SpecialFields::new(),
      };
      &instance
    }
  }

  ///  map<K,V>
  #[derive(PartialEq, Clone, Default, Debug)]
  // @@protoc_insertion_point(message:onnx.TypeProto.Map)
  pub struct Map {
    // message fields
    ///  This field MUST have a valid TensorProto.DataType value
    ///  This field MUST be present for this version of the IR.
    ///  This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
    // @@protoc_insertion_point(field:onnx.TypeProto.Map.key_type)
    pub key_type: Option<i32>,
    ///  This field MUST be present for this version of the IR.
    // @@protoc_insertion_point(field:onnx.TypeProto.Map.value_type)
    pub value_type: protobuf::MessageField<super::TypeProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TypeProto.Map.special_fields)
    pub special_fields: protobuf::SpecialFields,
  }

  impl<'a> Default for &'a Map {
    fn default() -> &'a Map {
      <Map as protobuf::Message>::default_instance()
    }
  }

  impl Map {
    pub fn new() -> Map {
      Default::default()
    }

    pub(crate) fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
      if structure_path.is_empty() { //simple types, direct children of map
        match attribute_name {
          "key_type" => self.set_key_type(integer_value),
          "special_fields" => {}
          _ => panic!("TYPE::MAP dispatcher simple types, method not found: {}", attribute_name)
        }
      } else { //complex types, here starts the dispatch recursion.
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "typeproto" => {
            match self.value_type.as_mut() {
              None => {
                self.value_type = protobuf::MessageField::some(super::TypeProto::new());
                match self.value_type.as_mut() {
                  None => { panic!("TYPE::MAP dispatcher, cannot insert len"); }
                  Some(v) => { v.special_fields.cached_size().set(integer_value as u32); }
                }
              }
              Some(v) => v.dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add)
            }
          }
          _ => panic!("TYPE::MAP dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      }
    }

    // optional int32 key_type = 1;
    pub fn key_type(&self) -> i32 {
      self.key_type.unwrap_or(0)
    }

    pub fn clear_key_type(&mut self) {
      self.key_type = None;
    }

    pub fn has_key_type(&self) -> bool {
      self.key_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: i32) {
      self.key_type = Some(v);
    }
  }

  impl protobuf::Message for Map {
    const NAME: &'static str = "Map";

    fn is_initialized(&self) -> bool {
      true
    }

    fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
      while let Some(tag) = is.read_raw_tag_or_eof()? {
        match tag {
          8 => {
            self.key_type = Some(is.read_int32()?);
          }
          18 => {
            protobuf::rt::read_singular_message_into_field(is, &mut self.value_type)?;
          }
          tag => {
            protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
          }
        };
      }
      Ok(())
    }

    fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
      if let Some(v) = self.key_type {
        os.write_int32(1, v)?;
      }
      if let Some(v) = self.value_type.as_ref() {
        protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
      }
      os.write_unknown_fields(self.special_fields.unknown_fields())?;
      Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
      let mut my_size = 0;
      if let Some(v) = self.key_type {
        my_size += protobuf::rt::int32_size(1, v);
      }
      if let Some(v) = self.value_type.as_ref() {
        let len = v.compute_size();
        my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
      }
      my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
      self.special_fields.cached_size().set(my_size as u32);
      my_size
    }

    fn special_fields(&self) -> &protobuf::SpecialFields {
      &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
      &mut self.special_fields
    }

    fn new() -> Map {
      Map::new()
    }

    fn clear(&mut self) {
      self.key_type = None;
      self.value_type.clear();
      self.special_fields.clear();
    }

    fn default_instance() -> &'static Map {
      static instance: Map = Map {
        key_type: None,
        value_type: protobuf::MessageField::none(),
        special_fields: protobuf::SpecialFields::new(),
      };
      &instance
    }
  }

  ///  wrapper for Tensor, Sequence, or Map
  #[derive(PartialEq, Clone, Default, Debug)]
  // @@protoc_insertion_point(message:onnx.TypeProto.Optional)
  pub struct Optional {
    // message fields
    ///  The type and optional shape of the element wrapped.
    ///  This field MUST be present for this version of the IR.
    ///  Possible values correspond to OptionalProto.DataType enum
    // @@protoc_insertion_point(field:onnx.TypeProto.Optional.elem_type)
    pub elem_type: protobuf::MessageField<super::TypeProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TypeProto.Optional.special_fields)
    pub special_fields: protobuf::SpecialFields,
  }

  impl<'a> Default for &'a Optional {
    fn default() -> &'a Optional {
      <Optional as protobuf::Message>::default_instance()
    }
  }

  impl Optional {
    pub fn new() -> Optional {
      Default::default()
    }

    pub(crate) fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
      if structure_path.is_empty() { //simple types, direct children of optional
        match attribute_name {
          "special_fields" => {}
          _ => panic!("TYPE::OPTIONAL dispatcher simple types, method not found: {}", attribute_name)
        }
      } else { //complex types, here starts the dispatch recursion.
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "typeproto" => {
            match self.elem_type.as_mut() {
              None => {
                self.elem_type = protobuf::MessageField::some(super::TypeProto::new());
                match self.elem_type.as_mut() {
                  None => { panic!("TYPE::OPTIONAL dispatcher, cannot insert len"); }
                  Some(e) => { e.special_fields.cached_size().set(integer_value as u32); }
                }
              }
              Some(e) => e.dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add)
            }
          }
          _ => panic!("TYPE::OPTIONAL dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      }
    }
  }

  impl protobuf::Message for Optional {
    const NAME: &'static str = "Optional";

    fn is_initialized(&self) -> bool {
      true
    }

    fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
      while let Some(tag) = is.read_raw_tag_or_eof()? {
        match tag {
          10 => {
            protobuf::rt::read_singular_message_into_field(is, &mut self.elem_type)?;
          }
          tag => {
            protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
          }
        };
      }
      Ok(())
    }

    fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
      if let Some(v) = self.elem_type.as_ref() {
        protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
      }
      os.write_unknown_fields(self.special_fields.unknown_fields())?;
      Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
      let mut my_size = 0;
      if let Some(v) = self.elem_type.as_ref() {
        let len = v.compute_size();
        my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
      }
      my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
      self.special_fields.cached_size().set(my_size as u32);
      my_size
    }

    fn special_fields(&self) -> &protobuf::SpecialFields {
      &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
      &mut self.special_fields
    }

    fn new() -> Optional {
      Optional::new()
    }

    fn clear(&mut self) {
      self.elem_type.clear();
      self.special_fields.clear();
    }

    fn default_instance() -> &'static Optional {
      static instance: Optional = Optional {
        elem_type: protobuf::MessageField::none(),
        special_fields: protobuf::SpecialFields::new(),
      };
      &instance
    }
  }

  #[derive(PartialEq, Clone, Default, Debug)]
  // @@protoc_insertion_point(message:onnx.TypeProto.SparseTensor)
  pub struct SparseTensor {
    // message fields
    ///  This field MUST NOT have the value of UNDEFINED
    ///  This field MUST have a valid TensorProto.DataType value
    ///  This field MUST be present for this version of the IR.
    // @@protoc_insertion_point(field:onnx.TypeProto.SparseTensor.elem_type)
    pub elem_type: Option<i32>,
    // @@protoc_insertion_point(field:onnx.TypeProto.SparseTensor.shape)
    pub shape: protobuf::MessageField<super::TensorShapeProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TypeProto.SparseTensor.special_fields)
    pub special_fields: protobuf::SpecialFields,
  }

  impl<'a> Default for &'a SparseTensor {
    fn default() -> &'a SparseTensor {
      <SparseTensor as protobuf::Message>::default_instance()
    }
  }

  impl SparseTensor {
    pub fn new() -> SparseTensor {
      Default::default()
    }

    pub(crate) fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
      if structure_path.is_empty() { //simple types, direct children of sparse_tensor
        match attribute_name {
          "elem_type" => self.set_elem_type(integer_value),
          "special_fields" => {}
          _ => panic!("TYPE::SPARSETENSOR dispatcher simple types, method not found: {}", attribute_name)
        }
      } else { //complex types, here starts the dispatch recursion.
        let next_child_to_dispatch = structure_path.get(0).unwrap();
        match next_child_to_dispatch.as_str() {
          "tensorshapeproto" => {
            match self.shape.as_mut() {
              None => {
                self.shape = protobuf::MessageField::some(super::TensorShapeProto::new());
                match self.shape.as_mut() {
                  None => { panic!("TYPE::SPARSETENSOR dispatcher, cannot insert len"); }
                  Some(s) => { s.special_fields.cached_size().set(integer_value as u32); }
                }
              }
              Some(s) => s.dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add)
            }
          }
          _ => panic!("TYPE::SPARSETENSOR dispatcher complex types, child not found: {}", next_child_to_dispatch)
        }
      }
    }

    // optional int32 elem_type = 1;
    pub fn elem_type(&self) -> i32 {
      self.elem_type.unwrap_or(0)
    }

    pub fn clear_elem_type(&mut self) {
      self.elem_type = None;
    }

    pub fn has_elem_type(&self) -> bool {
      self.elem_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: i32) {
      self.elem_type = Some(v);
    }
  }

  impl protobuf::Message for SparseTensor {
    const NAME: &'static str = "SparseTensor";

    fn is_initialized(&self) -> bool {
      true
    }

    fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
      while let Some(tag) = is.read_raw_tag_or_eof()? {
        match tag {
          8 => {
            self.elem_type = Some(is.read_int32()?);
          }
          18 => {
            protobuf::rt::read_singular_message_into_field(is, &mut self.shape)?;
          }
          tag => {
            protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
          }
        };
      }
      Ok(())
    }

    fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
      if let Some(v) = self.elem_type {
        os.write_int32(1, v)?;
      }
      if let Some(v) = self.shape.as_ref() {
        protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
      }
      os.write_unknown_fields(self.special_fields.unknown_fields())?;
      Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
      let mut my_size = 0;
      if let Some(v) = self.elem_type {
        my_size += protobuf::rt::int32_size(1, v);
      }
      if let Some(v) = self.shape.as_ref() {
        let len = v.compute_size();
        my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
      }
      my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
      self.special_fields.cached_size().set(my_size as u32);
      my_size
    }

    fn special_fields(&self) -> &protobuf::SpecialFields {
      &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
      &mut self.special_fields
    }

    fn new() -> SparseTensor {
      SparseTensor::new()
    }

    fn clear(&mut self) {
      self.elem_type = None;
      self.shape.clear();
      self.special_fields.clear();
    }

    fn default_instance() -> &'static SparseTensor {
      static instance: SparseTensor = SparseTensor {
        elem_type: None,
        shape: protobuf::MessageField::none(),
        special_fields: protobuf::SpecialFields::new(),
      };
      &instance
    }
  }
}

///  Operator Sets
///
///  OperatorSets are uniquely identified by a (domain, opset_version) pair.
#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.OperatorSetIdProto)
pub struct OperatorSetIdProto {
  // message fields
  ///  The domain of the operator set being identified.
  ///  The empty string ("") or absence of this field implies the operator
  ///  set that is defined as part of the ONNX specification.
  ///  This field MUST be present in this version of the IR when referring to any other operator set.
  // @@protoc_insertion_point(field:onnx.OperatorSetIdProto.domain)
  pub domain: Option<String>,
  ///  The version of the operator set being identified.
  ///  This field MUST be present in this version of the IR.
  // @@protoc_insertion_point(field:onnx.OperatorSetIdProto.version)
  pub version: Option<i64>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.OperatorSetIdProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a OperatorSetIdProto {
  fn default() -> &'a OperatorSetIdProto {
    <OperatorSetIdProto as protobuf::Message>::default_instance()
  }
}

impl OperatorSetIdProto {
  pub fn new() -> OperatorSetIdProto {
    Default::default()
  }

  fn dispatch(&mut self, /*unused*/ _current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, /*unused*/ _float_value: f32, string_value: String, /*unused*/ _new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of operator_set_id_proto
      match attribute_name {
        "domain" => self.set_domain(string_value),
        "version" => self.set_version(integer_value.into()),
        "special_fields" => {}
        _ => panic!("OPERATORSETIDPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else {
      panic!("OPERATORSETIDPROTO dispatcher complex types not allowed!: {:?}", structure_path)
    }
  }

  // optional string domain = 1;
  pub fn domain(&self) -> &str {
    match self.domain.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_domain(&mut self) {
    self.domain = None;
  }

  pub fn has_domain(&self) -> bool {
    self.domain.is_some()
  }

  // Param is passed by value, moved
  pub fn set_domain(&mut self, v: String) {
    self.domain = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_domain(&mut self) -> &mut String {
    if self.domain.is_none() {
      self.domain = Some(String::new());
    }
    self.domain.as_mut().unwrap()
  }

  // Take field
  pub fn take_domain(&mut self) -> String {
    self.domain.take().unwrap_or_else(|| String::new())
  }

  // optional int64 version = 2;

  pub fn version(&self) -> i64 {
    self.version.unwrap_or(0)
  }

  pub fn clear_version(&mut self) {
    self.version = None;
  }

  pub fn has_version(&self) -> bool {
    self.version.is_some()
  }

  // Param is passed by value, moved
  pub fn set_version(&mut self, v: i64) {
    self.version = Some(v);
  }
}

impl protobuf::Message for OperatorSetIdProto {
  const NAME: &'static str = "OperatorSetIdProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.domain = Some(is.read_string()?);
        }
        16 => {
          self.version = Some(is.read_int64()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.domain.as_ref() {
      os.write_string(1, v)?;
    }
    if let Some(v) = self.version {
      os.write_int64(2, v)?;
    }
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.domain.as_ref() {
      my_size += protobuf::rt::string_size(1, &v);
    }
    if let Some(v) = self.version {
      my_size += protobuf::rt::int64_size(2, v);
    }
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> OperatorSetIdProto {
    OperatorSetIdProto::new()
  }

  fn clear(&mut self) {
    self.domain = None;
    self.version = None;
    self.special_fields.clear();
  }

  fn default_instance() -> &'static OperatorSetIdProto {
    static instance: OperatorSetIdProto = OperatorSetIdProto {
      domain: None,
      version: None,
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

#[derive(PartialEq, Clone, Default, Debug)]
// @@protoc_insertion_point(message:onnx.FunctionProto)
pub struct FunctionProto {
  // message fields
  ///  The name of the function, similar usage of op_type in OperatorProto.
  ///  Combined with FunctionProto.domain, this forms the unique identity of
  ///  the FunctionProto.
  // @@protoc_insertion_point(field:onnx.FunctionProto.name)
  pub name: Option<String>,
  ///  The inputs and outputs of the function.
  // @@protoc_insertion_point(field:onnx.FunctionProto.input)
  pub input: Vec<String>,
  // @@protoc_insertion_point(field:onnx.FunctionProto.output)
  pub output: Vec<String>,
  ///  The attribute parameters of the function.
  ///  It is for function parameters without default values.
  // @@protoc_insertion_point(field:onnx.FunctionProto.attribute)
  pub attribute: Vec<String>,
  ///  The attribute protos of the function.
  ///  It is for function attributes with default values.
  ///  A function attribute shall be represented either as
  ///  a string attribute or an AttributeProto, not both.
  // @@protoc_insertion_point(field:onnx.FunctionProto.attribute_proto)
  pub attribute_proto: Vec<AttributeProto>,
  ///  The nodes in the function.
  // @@protoc_insertion_point(field:onnx.FunctionProto.node)
  pub node: Vec<NodeProto>,
  ///  A human-readable documentation for this function. Markdown is allowed.
  // @@protoc_insertion_point(field:onnx.FunctionProto.doc_string)
  pub doc_string: Option<String>,
  // @@protoc_insertion_point(field:onnx.FunctionProto.opset_import)
  pub opset_import: Vec<OperatorSetIdProto>,
  ///  The domain which this function belongs to. Combined with FunctionProto.name, this forms the unique identity of
  ///  the FunctionProto.
  // @@protoc_insertion_point(field:onnx.FunctionProto.domain)
  pub domain: Option<String>,
  // special fields
  // @@protoc_insertion_point(special_field:onnx.FunctionProto.special_fields)
  pub special_fields: protobuf::SpecialFields,
}

impl<'a> Default for &'a FunctionProto {
  fn default() -> &'a FunctionProto {
    <FunctionProto as protobuf::Message>::default_instance()
  }
}

impl FunctionProto {
  pub fn new() -> FunctionProto {
    Default::default()
  }

  fn dispatch(&mut self, current_structure: &[String], structure_path: &[String], attribute_name: &str, integer_value: i32, float_value: f32, string_value: String, new_structure_to_add: bool) {
    if structure_path.is_empty() { //simple types, direct children of function_proto
      match attribute_name {
        "name" => self.set_name(string_value),
        "input" => self.input.push(string_value),
        "output" => self.output.push(string_value),
        "attribute" => self.attribute.push(string_value),
        "doc_string" => self.set_doc_string(string_value),
        "domain" => self.set_domain(string_value),
        "special_fields" => {}
        _ => panic!("FUNCTIONPROTO dispatcher simple types, method not found: {}", attribute_name)
      }
    } else { //complex types, here starts the dispatch recursion.
      let next_child_to_dispatch = structure_path.get(0).unwrap();
      match next_child_to_dispatch.as_str() {
        "attributeproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.attribute_proto.push(AttributeProto::default());
            self.attribute_proto.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.attribute_proto.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "nodeproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.node.push(NodeProto::default());
            self.node.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.node.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        "operatorsetidproto" => {
          if new_structure_to_add && structure_path.len() == 1 {
            self.opset_import.push(OperatorSetIdProto::default());
            self.opset_import.last_mut().unwrap().special_fields.cached_size().set(integer_value as u32);
          } else {
            self.opset_import.last_mut().unwrap().dispatch(current_structure, &structure_path[1..], attribute_name, integer_value, float_value, string_value, new_structure_to_add);
          }
        }
        _ => panic!("FUNCTIONPROTO dispatcher complex types, child not found: {}", next_child_to_dispatch)
      }
    }
  }

  // optional string name = 1;
  pub fn name(&self) -> &str {
    match self.name.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_name(&mut self) {
    self.name = None;
  }

  pub fn has_name(&self) -> bool {
    self.name.is_some()
  }

  // Param is passed by value, moved
  pub fn set_name(&mut self, v: String) {
    self.name = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_name(&mut self) -> &mut String {
    if self.name.is_none() {
      self.name = Some(String::new());
    }
    self.name.as_mut().unwrap()
  }

  // Take field
  pub fn take_name(&mut self) -> String {
    self.name.take().unwrap_or_else(|| String::new())
  }

  // optional string doc_string = 8;

  pub fn doc_string(&self) -> &str {
    match self.doc_string.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_doc_string(&mut self) {
    self.doc_string = None;
  }

  pub fn has_doc_string(&self) -> bool {
    self.doc_string.is_some()
  }

  // Param is passed by value, moved
  pub fn set_doc_string(&mut self, v: String) {
    self.doc_string = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_doc_string(&mut self) -> &mut String {
    if self.doc_string.is_none() {
      self.doc_string = Some(String::new());
    }
    self.doc_string.as_mut().unwrap()
  }

  // Take field
  pub fn take_doc_string(&mut self) -> String {
    self.doc_string.take().unwrap_or_else(|| String::new())
  }

  // optional string domain = 10;

  pub fn domain(&self) -> &str {
    match self.domain.as_ref() {
      Some(v) => v,
      None => "",
    }
  }

  pub fn clear_domain(&mut self) {
    self.domain = None;
  }

  pub fn has_domain(&self) -> bool {
    self.domain.is_some()
  }

  // Param is passed by value, moved
  pub fn set_domain(&mut self, v: String) {
    self.domain = Some(v);
  }

  // Mutable pointer to the field.
  // If field is not initialized, it is initialized with default value first.
  pub fn mut_domain(&mut self) -> &mut String {
    if self.domain.is_none() {
      self.domain = Some(String::new());
    }
    self.domain.as_mut().unwrap()
  }

  // Take field
  pub fn take_domain(&mut self) -> String {
    self.domain.take().unwrap_or_else(|| String::new())
  }
}

impl protobuf::Message for FunctionProto {
  const NAME: &'static str = "FunctionProto";

  fn is_initialized(&self) -> bool {
    true
  }

  fn merge_from(&mut self, is: &mut protobuf::CodedInputStream<'_>) -> protobuf::Result<()> {
    while let Some(tag) = is.read_raw_tag_or_eof()? {
      match tag {
        10 => {
          self.name = Some(is.read_string()?);
        }
        34 => {
          self.input.push(is.read_string()?);
        }
        42 => {
          self.output.push(is.read_string()?);
        }
        50 => {
          self.attribute.push(is.read_string()?);
        }
        90 => {
          self.attribute_proto.push(is.read_message()?);
        }
        58 => {
          self.node.push(is.read_message()?);
        }
        66 => {
          self.doc_string = Some(is.read_string()?);
        }
        74 => {
          self.opset_import.push(is.read_message()?);
        }
        82 => {
          self.domain = Some(is.read_string()?);
        }
        tag => {
          protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
        }
      };
    }
    Ok(())
  }

  fn write_to_with_cached_sizes(&self, os: &mut protobuf::CodedOutputStream<'_>) -> protobuf::Result<()> {
    if let Some(v) = self.name.as_ref() {
      os.write_string(1, v)?;
    }
    for v in &self.input {
      os.write_string(4, &v)?;
    };
    for v in &self.output {
      os.write_string(5, &v)?;
    };
    for v in &self.attribute {
      os.write_string(6, &v)?;
    };
    for v in &self.attribute_proto {
      protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
    };
    for v in &self.node {
      protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
    };
    if let Some(v) = self.doc_string.as_ref() {
      os.write_string(8, v)?;
    }
    for v in &self.opset_import {
      protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
    };
    if let Some(v) = self.domain.as_ref() {
      os.write_string(10, v)?;
    }
    os.write_unknown_fields(self.special_fields.unknown_fields())?;
    Ok(())
  }

  // Compute sizes of nested messages
  #[allow(unused_variables)]
  fn compute_size(&self) -> u64 {
    let mut my_size = 0;
    if let Some(v) = self.name.as_ref() {
      my_size += protobuf::rt::string_size(1, &v);
    }
    for value in &self.input {
      my_size += protobuf::rt::string_size(4, &value);
    };
    for value in &self.output {
      my_size += protobuf::rt::string_size(5, &value);
    };
    for value in &self.attribute {
      my_size += protobuf::rt::string_size(6, &value);
    };
    for value in &self.attribute_proto {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    for value in &self.node {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    if let Some(v) = self.doc_string.as_ref() {
      my_size += protobuf::rt::string_size(8, &v);
    }
    for value in &self.opset_import {
      let len = value.compute_size();
      my_size += 1 + protobuf::rt::compute_raw_varint64_size(len) + len;
    };
    if let Some(v) = self.domain.as_ref() {
      my_size += protobuf::rt::string_size(10, &v);
    }
    my_size += protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
    self.special_fields.cached_size().set(my_size as u32);
    my_size
  }

  fn special_fields(&self) -> &protobuf::SpecialFields {
    &self.special_fields
  }

  fn mut_special_fields(&mut self) -> &mut protobuf::SpecialFields {
    &mut self.special_fields
  }

  fn new() -> FunctionProto {
    FunctionProto::new()
  }

  fn clear(&mut self) {
    self.name = None;
    self.input.clear();
    self.output.clear();
    self.attribute.clear();
    self.attribute_proto.clear();
    self.node.clear();
    self.doc_string = None;
    self.opset_import.clear();
    self.domain = None;
    self.special_fields.clear();
  }

  fn default_instance() -> &'static FunctionProto {
    static instance: FunctionProto = FunctionProto {
      name: None,
      input: Vec::new(),
      output: Vec::new(),
      attribute: Vec::new(),
      attribute_proto: Vec::new(),
      node: Vec::new(),
      doc_string: None,
      opset_import: Vec::new(),
      domain: None,
      special_fields: protobuf::SpecialFields::new(),
    };
    &instance
  }
}

///  Versioning
///
///  ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
///
///  To be compatible with both proto2 and proto3, we will use a version number
///  that is not defined by the default value but an explicit enum number.
#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
// @@protoc_insertion_point(enum:onnx.Version)
pub enum Version {
  // @@protoc_insertion_point(enum_value:onnx.Version._START_VERSION)
  _START_VERSION = 0,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_10_10)
  IR_VERSION_2017_10_10 = 1,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_10_30)
  IR_VERSION_2017_10_30 = 2,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_11_3)
  IR_VERSION_2017_11_3 = 3,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2019_1_22)
  IR_VERSION_2019_1_22 = 4,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2019_3_18)
  IR_VERSION_2019_3_18 = 5,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2019_9_19)
  IR_VERSION_2019_9_19 = 6,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2020_5_8)
  IR_VERSION_2020_5_8 = 7,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2021_7_30)
  IR_VERSION_2021_7_30 = 8,
  // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION)
  IR_VERSION = 9,
}

impl protobuf::Enum for Version {
  const NAME: &'static str = "Version";

  fn value(&self) -> i32 {
    *self as i32
  }

  fn from_i32(value: i32) -> Option<Version> {
    match value {
      0 => Some(Version::_START_VERSION),
      1 => Some(Version::IR_VERSION_2017_10_10),
      2 => Some(Version::IR_VERSION_2017_10_30),
      3 => Some(Version::IR_VERSION_2017_11_3),
      4 => Some(Version::IR_VERSION_2019_1_22),
      5 => Some(Version::IR_VERSION_2019_3_18),
      6 => Some(Version::IR_VERSION_2019_9_19),
      7 => Some(Version::IR_VERSION_2020_5_8),
      8 => Some(Version::IR_VERSION_2021_7_30),
      9 => Some(Version::IR_VERSION),
      _ => None
    }
  }

  fn from_str(s: &str) -> Option<Self> {
    todo!()
  }

  const VALUES: &'static [Version] = &[
    Version::_START_VERSION,
    Version::IR_VERSION_2017_10_10,
    Version::IR_VERSION_2017_10_30,
    Version::IR_VERSION_2017_11_3,
    Version::IR_VERSION_2019_1_22,
    Version::IR_VERSION_2019_3_18,
    Version::IR_VERSION_2019_9_19,
    Version::IR_VERSION_2020_5_8,
    Version::IR_VERSION_2021_7_30,
    Version::IR_VERSION,
  ];
}

impl Default for Version {
  fn default() -> Self {
    Version::_START_VERSION
  }
}


///  Operator/function status.
#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
// @@protoc_insertion_point(enum:onnx.OperatorStatus)
pub enum OperatorStatus {
  // @@protoc_insertion_point(enum_value:onnx.OperatorStatus.EXPERIMENTAL)
  EXPERIMENTAL = 0,
  // @@protoc_insertion_point(enum_value:onnx.OperatorStatus.STABLE)
  STABLE = 1,
}

impl protobuf::Enum for OperatorStatus {
  const NAME: &'static str = "OperatorStatus";

  fn value(&self) -> i32 {
    *self as i32
  }

  fn from_i32(value: i32) -> Option<OperatorStatus> {
    match value {
      0 => Some(OperatorStatus::EXPERIMENTAL),
      1 => Some(OperatorStatus::STABLE),
      _ => None
    }
  }

  fn from_str(s: &str) -> Option<Self> {
    todo!()
  }

  const VALUES: &'static [OperatorStatus] = &[
    OperatorStatus::EXPERIMENTAL,
    OperatorStatus::STABLE,
  ];
}

impl Default for OperatorStatus {
  fn default() -> Self {
    OperatorStatus::EXPERIMENTAL
  }
}

pub fn current_structure_search(current_structure: &[String], len: usize) -> String {
  if current_structure.len() < len {
    panic!("cannot get {}-nth element of current_structure which contains {:?}", len, current_structure);
  }
  match current_structure.get(current_structure.len() - len) {
    Some(s) => s.clone(),
    None => panic!("cannot get {}-nth element of current_structure which contains {:?}", current_structure.len() - len, current_structure)
  }
}